<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>马年红包 · 手势召唤祝福</title>

  <!-- ES Module Shims (Import Maps) -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/build/three.module.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/EffectComposer.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/RenderPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/UnrealBloomPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/OutputPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/ShaderPass.js">

  <script type="importmap-shim">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --gold:#d4af37;
      --gold2:#f5d77a;
      --red:#b11226;
      --red2:#ff2a4f;
      --ink:#050607;
      --panel: rgba(10,10,12,.62);
      --panel2: rgba(0,0,0,.45);
      --line: rgba(212,175,55,.35);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(140% 140% at 50% 28%, #140306 0%, #070608 55%, #040406 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }

    #app{ position:fixed; inset:0; }

    canvas#gl{
      position:absolute; inset:0;
      width:100%; height:100%;
      display:block;
      touch-action:none;
    }

    /* cinematic vignette + haze */
    .cinema{
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(120% 120% at 50% 42%, rgba(0,0,0,0) 40%, rgba(0,0,0,.62) 100%),
        radial-gradient(90% 60% at 50% 0%, rgba(212,175,55,.12) 0%, rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(177,18,38,.10) 0%, rgba(0,0,0,0) 45%);
      mix-blend-mode:screen;
      opacity:.95;
    }
    .grain{
      position:absolute; inset:-20%;
      pointer-events:none;
      background-image:
        repeating-linear-gradient(0deg, rgba(255,255,255,.025) 0 1px, rgba(0,0,0,0) 1px 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.018) 0 1px, rgba(0,0,0,0) 1px 4px);
      opacity:.22;
      transform:rotate(2deg);
      animation: grain 7s linear infinite;
      mix-blend-mode:overlay;
      filter: blur(.2px);
    }
    @keyframes grain{
      0%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
      50%{ transform:translate3d(2%, 1%, 0) rotate(2deg); }
      100%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
    }

    .hud{
      position:absolute;
      left:12px; right:12px; top:12px;
      display:flex; justify-content:center;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      width:min(980px, calc(100vw - 24px));
      padding:12px 12px 10px;
      border:1px solid var(--line);
      border-radius:14px;
      background:linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .brand{ display:flex; gap:10px; align-items:center; min-width:260px; }
    .badge{
      width:12px; height:12px; border-radius:999px;
      background:var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.18), 0 0 18px rgba(212,175,55,.45);
    }
    .title{ font-weight:800; letter-spacing:.4px; font-size:14px; line-height:1.2; }
    .subtitle{ font-size:12px; color:var(--muted); margin-top:2px; }
    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-left:auto; }

    button{
      pointer-events:auto;
      appearance:none;
      border:1px solid rgba(212,175,55,.38);
      color:var(--text);
      background:linear-gradient(180deg, rgba(177,18,38,.28), rgba(0,0,0,.25));
      border-radius:12px;
      padding:10px 12px;
      font-size:12px;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
      user-select:none;
    }
    button.secondary{
      border-color: rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.18));
      color: rgba(255,255,255,.86);
    }
    button:active{ transform: translateY(1px); }

    .tips{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(212,175,55,.22);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-size:12px;
      color:rgba(255,255,255,.78);
    }
    .chip{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius:999px;
      padding:6px 10px;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .chip b{ color:rgba(255,255,255,.92); font-weight:900; }

    .status{
      margin-left:auto;
      font-size:12px;
      color:rgba(255,255,255,.72);
      display:flex; align-items:center; gap:8px;
    }
    .led{
      width:8px; height:8px; border-radius:999px;
      background: rgba(255,255,255,.18);
      box-shadow:0 0 0 2px rgba(255,255,255,.06);
    }
    .led.on{
      background: var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.16), 0 0 16px rgba(212,175,55,.55);
    }

    /* Focus overlay */
    .focusOverlay{
      position:absolute; inset:0;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding:16px 12px 22px;
      pointer-events:none;
      opacity:0;
      transform: translate3d(0, 10px, 0);
      transition: opacity .25s ease, transform .25s ease;
    }
    .focusOverlay.show{
      opacity:1;
      transform: translate3d(0,0,0);
    }
    .focusCard{
      pointer-events:auto;
      width:min(820px, calc(100vw - 24px));
      border-radius:18px;
      border:1px solid rgba(212,175,55,.42);
      background: linear-gradient(180deg, rgba(0,0,0,.52), rgba(8,12,14,.62));
      box-shadow: 0 22px 70px rgba(0,0,0,.58);
      backdrop-filter: blur(12px);
      padding:14px 14px 12px;
      position:relative;
      overflow:hidden;
    }
    .focusCard:before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(60% 120% at 20% 0%, rgba(212,175,55,.18), rgba(0,0,0,0) 55%),
                  radial-gradient(60% 120% at 80% 0%, rgba(177,18,38,.16), rgba(0,0,0,0) 55%);
      pointer-events:none;
    }
    .focusCard h3{
      margin:0;
      font-size:14px;
      letter-spacing:.5px;
      position:relative;
    }
    .focusCard p{
      margin:8px 0 0;
      font-size:14px;
      line-height:1.55;
      color: rgba(255,255,255,.90);
      position:relative;
      white-space:pre-wrap;
    }
    .small{
      margin-top:10px;
      font-size:12px;
      color: rgba(255,255,255,.65);
      position:relative;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .kbd{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius:10px;
      padding:6px 10px;
    }

    video#cam{
      position:absolute;
      right:12px; bottom:12px;
      width:120px; height:160px;
      opacity:0;
      pointer-events:none;
    }

    @media (max-width:420px){
      .brand{ min-width: 220px; }
      .panel{ padding:10px; }
      button{ padding:9px 10px; }
      .tips{ gap:8px; }
    }
  </style>
</head>

<body>
<div id="app">
  <canvas id="gl"></canvas>
  <div class="cinema"></div>
  <div class="grain"></div>

  <div class="hud">
    <div class="panel">
      <div class="row">
        <div class="brand">
          <span class="badge"></span>
          <div>
            <div class="title">马年红包 · 手势召唤祝福</div>
            <div class="subtitle">Three.js / WebGL · MediaPipe Hands · 电影感辉光</div>
          </div>
        </div>

        <div class="controls">
          <button id="btnStart">启用手势</button>
          <button id="btnReset" class="secondary">重置</button>
          <button id="btnHelp" class="secondary">玩法提示</button>
          <button id="btnMusic" class="secondary">音乐：关</button>
        </div>

        <div class="status">
          <span id="led" class="led"></span>
          <span id="statusText">默认：合拢成语（可用鼠标拖拽/点击作为备用）</span>
        </div>
      </div>

      <div class="tips" id="tips" style="display:none;">
        <span class="chip"><b>握拳</b> → 合拢成语（随机换一条）</span>
        <span class="chip"><b>张开五指</b> → 散开漂浮</span>
        <span class="chip"><b>掌心移动/旋转</b> → 散开状态下旋转视角</span>
        <span class="chip"><b>三指抓</b> → 抓红包开封 → 播放马视频 + 成语</span>
        <span class="chip"><b>鼠标双击</b> → 备用抓红包</span>
      </div>
    </div>
  </div>

  <div id="focusOverlay" class="focusOverlay">
    <div class="focusCard">
      <h3 id="focusTitle">红包开封</h3>
      <p id="focusText">正在为你抽取马年祝福…</p>
      <div class="small">
        <span class="kbd">再次三指抓：换一个红包</span>
        <span class="kbd">握拳：回到合拢成语</span>
        <span class="kbd">张开手：回到散开漂浮</span>
      </div>
    </div>
  </div>

  <video id="cam" playsinline></video>
  <audio id="bgm" preload="none" loop playsinline></audio>
</div>

<script type="module-shim">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

/* ---------------------------
   Constants / UI
--------------------------- */
const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const DPR_CAP = IS_MOBILE ? 1.2 : 2.0;

const COLORS = {
  gold: new THREE.Color("#d4af37"),
  gold2: new THREE.Color("#f5d77a"),
  red:  new THREE.Color("#b11226"),
  red2: new THREE.Color("#ff2a4f"),
  ink:  new THREE.Color("#050607"),
  bg0:  new THREE.Color("#040406")
};

const IDIOMS = [
  "马到成功","龙马精神","一马当先","万马奔腾","马上发财","马上如意",
  "策马扬鞭","快马加鞭","一马平川","天马行空","马到功成","马跃钱程",
  "人强马壮","金戈铁马","骏马奔腾","马蹄生风",
  "马年大吉","马年行大运","马年祥瑞","金马迎春","宝马香车","马首是瞻",
  "马到财来","马到福来","马到运来",
  "马上有钱","马上有房","马上有对象","马力全开"
];

const VIDEO_LIST = [
  "assets/videos/horse1.mp4",
  "assets/videos/horse2.mp4",
  "assets/videos/horse3.mp4"
];

const BGM_URL = "assets/music/newyear.mp3";

const canvas = document.getElementById("gl");
const statusText = document.getElementById("statusText");
const led = document.getElementById("led");
const btnStart = document.getElementById("btnStart");
const btnReset = document.getElementById("btnReset");
const btnHelp = document.getElementById("btnHelp");
const tips = document.getElementById("tips");
const btnMusic = document.getElementById("btnMusic");
const bgm = document.getElementById("bgm");
const focusOverlay = document.getElementById("focusOverlay");
const focusTitleEl = document.getElementById("focusTitle");
const focusTextEl = document.getElementById("focusText");
const camVideoEl = document.getElementById("cam");

/* ---------------------------
   Helpers
--------------------------- */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const damp = (current,target,lambda,dt)=>{
  const t = 1 - Math.exp(-lambda*dt);
  return current + (target-current)*t;
};
function randPick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

function makeMaSpriteTexture({
  size=256,
  text="马",
  fill="#f5d77a",
  stroke="#b11226",
  glow="#d4af37",
  fontWeight=900
}={}){
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const ctx = c.getContext("2d");

  // soft glow background
  const g = ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size*0.48);
  g.addColorStop(0, "rgba(212,175,55,0.22)");
  g.addColorStop(1, "rgba(212,175,55,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,size,size);

  // draw glyph
  ctx.save();
  ctx.translate(size/2,size/2);
  ctx.textAlign="center";
  ctx.textBaseline="middle";

  const fontPx = Math.floor(size*0.70);
  ctx.font = `${fontWeight} ${fontPx}px "PingFang SC","Microsoft YaHei",ui-sans-serif,system-ui`;
  ctx.lineJoin="round";

  // thick outer glow
  ctx.shadowColor = glow;
  ctx.shadowBlur = Math.floor(size*0.12);
  ctx.strokeStyle = "rgba(212,175,55,0.55)";
  ctx.lineWidth = Math.floor(size*0.07);
  ctx.strokeText(text, 0, Math.floor(size*0.02));

  // red stroke to increase edge definition
  ctx.shadowBlur = 0;
  ctx.strokeStyle = stroke;
  ctx.lineWidth = Math.floor(size*0.055);
  ctx.strokeText(text, 0, Math.floor(size*0.02));

  // gold fill
  const fg = ctx.createLinearGradient(0,-size/2,0,size/2);
  fg.addColorStop(0, fill);
  fg.addColorStop(1, "#d4af37");
  ctx.fillStyle = fg;
  ctx.fillText(text, 0, Math.floor(size*0.02));

  // small glitter
  for(let i=0;i<18;i++){
    const x = (Math.random()-0.5)*size*0.70;
    const y = (Math.random()-0.5)*size*0.70;
    const r = 1.2 + Math.random()*2.2;
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${0.15+Math.random()*0.35})`;
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
  }

  ctx.restore();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}

function sampleTextPoints(text, {
  fontSize=220,
  step=3,
  threshold=16,
  worldWidth=7.2,
  fontWeight=900,
  paddingRatio=0.45
}={}){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d", { willReadFrequently:true });

  const font = `${fontWeight} ${fontSize}px "PingFang SC","Microsoft YaHei",ui-sans-serif,system-ui`;
  ctx.font = font;
  const m = ctx.measureText(text);
  const pad = Math.ceil(fontSize*paddingRatio);

  const cssW = Math.ceil(m.width + pad*2);
  const cssH = Math.ceil(fontSize*1.3 + pad*2);

  c.width  = Math.ceil(cssW*dpr);
  c.height = Math.ceil(cssH*dpr);

  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  // Slightly thicker white to get clearer edges
  ctx.font = font;
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.fillStyle="#ffffff";
  ctx.fillText(text, cssW/2, cssH/2);

  // optional: stroke to widen sampling edges (improves outline)
  ctx.lineJoin="round";
  ctx.strokeStyle="rgba(255,255,255,0.85)";
  ctx.lineWidth = Math.max(2, Math.floor(fontSize*0.03));
  ctx.strokeText(text, cssW/2, cssH/2);

  const img = ctx.getImageData(0,0,c.width,c.height).data;

  const pts = [];
  const stepPx = Math.max(1, Math.round(step*dpr));
  for(let y=0;y<c.height;y+=stepPx){
    for(let x=0;x<c.width;x+=stepPx){
      const a = img[(y*c.width+x)*4+3];
      if(a>threshold) pts.push([x/dpr, y/dpr]);
    }
  }

  const scale = worldWidth / cssW;
  const out = new Float32Array(pts.length*3);
  for(let i=0;i<pts.length;i++){
    const [xCss,yCss]=pts[i];
    const px = (xCss - cssW/2)*scale;
    const py = (cssH/2 - yCss)*scale;
    out[i*3+0]=px;
    out[i*3+1]=py;
    out[i*3+2]=0;
  }

  return { positions: out, count: pts.length, cssW, cssH };
}

function makeGoldStampTexture(){
  const c=document.createElement("canvas");
  c.width=256; c.height=256;
  const ctx=c.getContext("2d");

  const bg=ctx.createRadialGradient(128,128,0,128,128,120);
  bg.addColorStop(0,"rgba(212,175,55,.45)");
  bg.addColorStop(1,"rgba(212,175,55,0)");
  ctx.fillStyle=bg;
  ctx.fillRect(0,0,256,256);

  // stamp ring
  ctx.beginPath();
  ctx.arc(128,128,64,0,Math.PI*2);
  ctx.strokeStyle="rgba(245,215,122,.85)";
  ctx.lineWidth=10;
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(128,128,48,0,Math.PI*2);
  ctx.strokeStyle="rgba(212,175,55,.8)";
  ctx.lineWidth=6;
  ctx.stroke();

  // center glyph "福"
  ctx.save();
  ctx.translate(128,128);
  ctx.textAlign="center";
  ctx.textBaseline="middle";
  ctx.font=`900 86px "PingFang SC","Microsoft YaHei",ui-sans-serif`;
  ctx.fillStyle="rgba(245,215,122,.95)";
  ctx.shadowColor="rgba(212,175,55,.55)";
  ctx.shadowBlur=14;
  ctx.fillText("福",0,6);
  ctx.restore();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}

/* ---------------------------
   Three.js Setup
--------------------------- */
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias:true,
  alpha:false,
  powerPreference:"high-performance"
});
renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio||1));
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.06;

const scene = new THREE.Scene();
scene.background = COLORS.bg0;

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 160);
// 把相机稍微拉远：更容易看到四字全貌
camera.position.set(0, 2.25, 10.6);

scene.add(new THREE.AmbientLight(0xffffff, 0.20));
const key = new THREE.DirectionalLight(0xfff2d6, 1.00);
key.position.set(6, 8, 6);
scene.add(key);
const rim = new THREE.DirectionalLight(0xd4af37, 0.55);
rim.position.set(-6, 4, -6);
scene.add(rim);

const goldPoint = new THREE.PointLight(0xd4af37, 1.10, 24, 2);
goldPoint.position.set(0, 4.5, 2.2);
scene.add(goldPoint);

const redPoint = new THREE.PointLight(0xb11226, 0.75, 18, 2);
redPoint.position.set(-2.4, 3.0, 2.2);
scene.add(redPoint);

/* ---------------------------
   Postprocessing (Selective Bloom)
--------------------------- */
const BLOOM_LAYER = 1;

const bloomComposer = new EffectComposer(renderer);
bloomComposer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.18, 0.62, 0.16
);
bloomComposer.addPass(bloomPass);

const finalComposer = new EffectComposer(renderer);
finalComposer.addPass(new RenderPass(scene, camera));
const bloomMixPass = new ShaderPass(
  new THREE.ShaderMaterial({
    uniforms:{
      baseTexture:{ value:null },
      bloomTexture:{ value:bloomComposer.renderTarget2.texture },
      uBloomIntensity:{ value: 1.0 }
    },
    vertexShader:`
      varying vec2 vUv;
      void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }
    `,
    fragmentShader:`
      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;
      uniform float uBloomIntensity;
      varying vec2 vUv;
      void main(){
        vec4 base = texture2D(baseTexture, vUv);
        vec4 bloom = texture2D(bloomTexture, vUv);
        gl_FragColor = base + bloom*uBloomIntensity;
      }
    `
  }),
  "baseTexture"
);
finalComposer.addPass(bloomMixPass);
finalComposer.addPass(new OutputPass());

/* ---------------------------
   Modes
--------------------------- */
const Mode = {
  COHESION: "COHESION",   // 合拢成语
  SCATTER:  "SCATTER",    // 散开漂浮
  REVEAL:   "REVEAL"      // 抓红包开封 + 视频
};
let mode = Mode.COHESION;

let mix = 0;       // 0=合拢，1=散开
let targetMix = 0;

let reveal = 0;    // 0=未进入开封，1=已进入开封/视频
let targetReveal = 0;

function setMode(next){
  if(mode===next) return;
  mode = next;

  if(mode===Mode.COHESION){
    targetMix = 0;
    targetReveal = 0;
    focusOverlay.classList.remove("show");
    // 每次回到合拢：换一个随机成语
    pickNewIdiom(true);
    statusText.textContent = "合拢成语：握拳可随机换一条；张开手可散开漂浮。";
  }else if(mode===Mode.SCATTER){
    targetMix = 1;
    targetReveal = 0;
    focusOverlay.classList.remove("show");
    statusText.textContent = "散开漂浮：掌心移动/旋转可旋转视角；三指抓可抓红包。";
  }else if(mode===Mode.REVEAL){
    targetMix = 1;
    targetReveal = 1;
    focusOverlay.classList.add("show");
    statusText.textContent = "抓到红包：开封后播放马视频，并显示随机马年成语。";
  }
}

/* ---------------------------
   Idiom Particles (马字精灵粒子)
--------------------------- */
const idiomGroup = new THREE.Group();
scene.add(idiomGroup);

// 整体往后放一点（“距离摄像机太近”的问题）
idiomGroup.position.set(0, 2.35, -2.2);

const MA_SPRITE = makeMaSpriteTexture();
const IDIOM_PARTICLE_COUNT = IS_MOBILE ? 9000 : 14000;

// build geometry with aHome from sampled idiom points, and aScatter random sphere
let idiomCurrent = "";
let idiomHomePositions = null;
let idiomHomeCount = 0;

function buildIdiomTargets(text){
  const sample = sampleTextPoints(text, {
    fontSize: IS_MOBILE ? 190 : 230,
    step: IS_MOBILE ? 4 : 3,          // 更密一点：边缘更清晰
    threshold: 10,
    worldWidth: IS_MOBILE ? 7.0 : 8.4 // 字整体更大一些，但放远了，所以不压脸
  });
  idiomHomePositions = sample.positions;
  idiomHomeCount = sample.count;
}

const idiomGeo = new THREE.BufferGeometry();
const aHome = new Float32Array(IDIOM_PARTICLE_COUNT*3);
const aScatter = new Float32Array(IDIOM_PARTICLE_COUNT*3);
const aRand = new Float32Array(IDIOM_PARTICLE_COUNT);
const aHue = new Float32Array(IDIOM_PARTICLE_COUNT);

function sampleScatterSphere(){
  const R = 6.8;
  const u=Math.random(), v=Math.random();
  const theta=u*Math.PI*2;
  const phi=Math.acos(2*v-1);
  const rr=(0.48 + Math.pow(Math.random(),0.70)*0.52)*R;
  const x=rr*Math.sin(phi)*Math.cos(theta);
  const y=rr*Math.cos(phi)*0.78 + 2.2;
  const z=rr*Math.sin(phi)*Math.sin(theta);
  return new THREE.Vector3(x,y,z);
}

function applyIdiomTargetsToAttributes(){
  if(!idiomHomePositions) return;
  for(let i=0;i<IDIOM_PARTICLE_COUNT;i++){
    const j = (i % idiomHomeCount);
    aHome[i*3+0] = idiomHomePositions[j*3+0];
    aHome[i*3+1] = idiomHomePositions[j*3+1];
    aHome[i*3+2] = idiomHomePositions[j*3+2];

    const s = sampleScatterSphere();
    aScatter[i*3+0]=s.x;
    aScatter[i*3+1]=s.y;
    aScatter[i*3+2]=s.z;

    aRand[i]=Math.random();
    aHue[i]=Math.random(); // 给少量彩点（更喜庆但不喧宾夺主）
  }
  idiomGeo.setAttribute("aHome", new THREE.BufferAttribute(aHome,3));
  idiomGeo.setAttribute("aScatter", new THREE.BufferAttribute(aScatter,3));
  idiomGeo.setAttribute("aRand", new THREE.BufferAttribute(aRand,1));
  idiomGeo.setAttribute("aHue", new THREE.BufferAttribute(aHue,1));
  // 给一个 position 防止 frustum/bounds 异常
  idiomGeo.setAttribute("position", new THREE.BufferAttribute(aHome,3));
  idiomGeo.computeBoundingSphere();
}

const idiomMat = new THREE.ShaderMaterial({
  transparent:true,
  depthWrite:false,
  blending:THREE.AdditiveBlending,
  uniforms:{
    uTime:{ value:0 },
    uMix:{ value:0 },
    uSprite:{ value: MA_SPRITE },
    uBaseSize:{ value: IS_MOBILE ? 0.78 : 0.72 },  // 粒子更小（你的要求）
    uColorGold:{ value: new THREE.Color("#d4af37") },
    uColorRed:{ value: new THREE.Color("#b11226") },
    uColorGold2:{ value: new THREE.Color("#f5d77a") },
    uFocus:{ value: 0 }
  },
  vertexShader:`
    uniform float uTime;
    uniform float uMix;
    uniform float uBaseSize;
    uniform float uFocus;

    attribute vec3 aHome;
    attribute vec3 aScatter;
    attribute float aRand;
    attribute float aHue;

    varying float vRand;
    varying float vHue;
    varying float vTw;

    void main(){
      vRand = aRand;
      vHue = aHue;

      vec3 pos = mix(aHome, aScatter, uMix);

      // 更轻的漂浮，避免边缘模糊
      float t = uTime * (0.55 + aRand*1.1);
      float wob = (0.05 + 0.10*uMix);
      pos.x += sin(t + aRand*6.2831) * wob;
      pos.y += cos(t*0.9 + aRand*5.0) * wob * 0.75;
      pos.z += sin(t*0.8 + aRand*4.0) * wob;

      // REVEAL 时略微“远景扩散”，让红包/烟花更突出
      pos *= (1.0 + uFocus * 0.08);

      vec4 mv = modelViewMatrix * vec4(pos, 1.0);
      gl_Position = projectionMatrix * mv;

      float dist = max(0.001, -mv.z);

      // 粒子小 + 更稳定（不靠得太近时也不会炸大）
      float tw = 0.78 + 0.22*sin(uTime*2.0 + aRand*10.0);
      gl_PointSize = clamp(uBaseSize * tw * (110.0/dist), 0.7, 2.2);

      vTw = tw;
    }
  `,
  fragmentShader:`
    precision highp float;
    uniform sampler2D uSprite;
    uniform vec3 uColorGold;
    uniform vec3 uColorGold2;
    uniform vec3 uColorRed;
    uniform float uFocus;

    varying float vRand;
    varying float vHue;
    varying float vTw;

    // simple HSV-ish tint for occasional colorful sparkles
    vec3 hueToRgb(float h){
      float r = abs(h*6.0 - 3.0) - 1.0;
      float g = 2.0 - abs(h*6.0 - 2.0);
      float b = 2.0 - abs(h*6.0 - 4.0);
      return clamp(vec3(r,g,b), 0.0, 1.0);
    }

    void main(){
      vec2 uv = gl_PointCoord;
      vec4 s = texture2D(uSprite, uv);

      // alpha from sprite (already has outline)
      float a = s.a;
      if(a < 0.05) discard;

      // base gold/red palette (more festive than white)
      float m1 = smoothstep(0.10, 0.92, vRand);
      vec3 col = mix(uColorGold2, uColorGold, m1);
      col = mix(col, uColorRed, smoothstep(0.82, 0.98, vRand)*0.55);

      // occasional colorful points when in REVEAL (firework vibe complement)
      float colorful = smoothstep(0.55, 1.0, uFocus) * smoothstep(0.975, 1.0, vRand);
      vec3 c2 = hueToRgb(vHue);
      col = mix(col, c2, colorful);

      // gentle glow gain
      float glow = (0.75 + 0.55*vTw) * (1.0 + 0.20*uFocus);
      gl_FragColor = vec4(col * (1.10 + 0.60*(1.0-a)), a * glow);
    }
  `
});

const idiomPoints = new THREE.Points(idiomGeo, idiomMat);
idiomGroup.add(idiomPoints);
idiomPoints.layers.enable(BLOOM_LAYER);

function pickNewIdiom(forceRebuild=false){
  const next = randPick(IDIOMS);
  if(next===idiomCurrent && !forceRebuild) return;
  idiomCurrent = next;

  buildIdiomTargets(idiomCurrent);
  applyIdiomTargetsToAttributes();
}

pickNewIdiom(true);

/* ---------------------------
   Red Envelopes (红包 Instanced)
--------------------------- */
const envelopeGroup = new THREE.Group();
scene.add(envelopeGroup);

const STAMP_TEX = makeGoldStampTexture();

function makeEnvelopeMaterial(){
  // base red + subtle metallic highlight
  return new THREE.MeshStandardMaterial({
    color: COLORS.red,
    metalness: 0.35,
    roughness: 0.55,
    emissive: COLORS.red.clone().multiplyScalar(0.18),
    emissiveIntensity: 0.9
  });
}
function makeStampMaterial(){
  return new THREE.MeshBasicMaterial({
    map: STAMP_TEX,
    transparent:true,
    opacity: 0.92,
    toneMapped:false
  });
}

const ENVELOPE_COUNT = IS_MOBILE ? 180 : 320;
const envGeo = new THREE.PlaneGeometry(0.26, 0.36);
const envMat = makeEnvelopeMaterial();
const envelopes = new THREE.InstancedMesh(envGeo, envMat, ENVELOPE_COUNT);
envelopes.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
envelopeGroup.add(envelopes);

// a separate instanced stamp (front)
const stampGeo = new THREE.PlaneGeometry(0.14, 0.14);
const stampMat = makeStampMaterial();
const stamps = new THREE.InstancedMesh(stampGeo, stampMat, ENVELOPE_COUNT);
stamps.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
envelopeGroup.add(stamps);
stamps.layers.enable(BLOOM_LAYER);

const envScatter = new Array(ENVELOPE_COUNT);
const envSeed = new Array(ENVELOPE_COUNT);
for(let i=0;i<ENVELOPE_COUNT;i++){
  envScatter[i] = sampleScatterSphere();
  envSeed[i] = Math.random()*1000;
}

const _obj = new THREE.Object3D();
function updateEnvelopes(time, mix, focus, dt){
  // in COHESION: envelopes exist but faint and further, so idiom dominates
  const baseOpacity = lerp(0.35, 0.95, mix);
  envMat.opacity = baseOpacity;
  envMat.transparent = true;

  for(let i=0;i<ENVELOPE_COUNT;i++){
    const s = envScatter[i];
    const t = time*(0.6 + (envSeed[i]%1.0)*1.2);

    // idle drift
    let x = s.x + Math.sin(t + envSeed[i])*0.12;
    let y = s.y + Math.cos(t*0.9 + envSeed[i])*0.10;
    let z = s.z + Math.sin(t*0.8 + envSeed[i])*0.12;

    // reveal focus: spread slightly
    const k = 1.0 + focus*0.08;
    x*=k; y*=k; z*=k;

    _obj.position.set(x,y,z);
    _obj.lookAt(camera.position);

    // subtle wobble rotation
    _obj.rotateZ(Math.sin(t*0.7)*0.10);
    _obj.rotateX(Math.cos(t*0.5)*0.06);

    const sc = 0.85 + (i%5)*0.03;
    _obj.scale.set(sc, sc, 1);
    _obj.updateMatrix();
    envelopes.setMatrixAt(i, _obj.matrix);

    // stamp (slightly in front)
    _obj.position.set(x,y,z+0.002);
    _obj.scale.set(sc*0.92, sc*0.92, 1);
    _obj.updateMatrix();
    stamps.setMatrixAt(i, _obj.matrix);
  }
  envelopes.instanceMatrix.needsUpdate = true;
  stamps.instanceMatrix.needsUpdate = true;
}

/* ---------------------------
   Grab Envelope: single animated envelope with "open" flap
--------------------------- */
const grabGroup = new THREE.Group();
scene.add(grabGroup);
grabGroup.visible = false;

// main body
const grabBody = new THREE.Mesh(new THREE.PlaneGeometry(0.60, 0.84), makeEnvelopeMaterial());
grabBody.material.emissive = COLORS.red.clone().multiplyScalar(0.22);
grabBody.material.emissiveIntensity = 1.0;
grabGroup.add(grabBody);
grabBody.layers.enable(BLOOM_LAYER);

// stamp
const grabStamp = new THREE.Mesh(new THREE.PlaneGeometry(0.30, 0.30), makeStampMaterial());
grabStamp.position.z = 0.004;
grabGroup.add(grabStamp);
grabStamp.layers.enable(BLOOM_LAYER);

// flap (top cover)
const flapGeo = new THREE.PlaneGeometry(0.62, 0.46);
const flapMat = makeEnvelopeMaterial();
flapMat.emissive = COLORS.red.clone().multiplyScalar(0.20);
flapMat.emissiveIntensity = 0.95;
const grabFlap = new THREE.Mesh(flapGeo, flapMat);
grabFlap.position.set(0, 0.21, 0.006);
grabGroup.add(grabFlap);

// hinge at top edge
grabFlap.geometry.translate(0, -0.23, 0);
grabFlap.position.y = 0.44;

// video plane (Three.js VideoTexture)
const videoGroup = new THREE.Group();
scene.add(videoGroup);
videoGroup.visible = false;

const videoEl = document.createElement("video");
videoEl.playsInline = true;
videoEl.muted = true;       // 绝大多数浏览器允许 muted 自动播放
videoEl.loop = true;
videoEl.preload = "auto";
videoEl.crossOrigin = "anonymous";

const videoTex = new THREE.VideoTexture(videoEl);
videoTex.colorSpace = THREE.SRGBColorSpace;
videoTex.minFilter = THREE.LinearFilter;
videoTex.magFilter = THREE.LinearFilter;
videoTex.generateMipmaps = false;

const videoMat = new THREE.MeshBasicMaterial({ map: videoTex, toneMapped:false });
const videoPlane = new THREE.Mesh(new THREE.PlaneGeometry(2.55, 1.55), videoMat);
videoGroup.add(videoPlane);
videoPlane.layers.enable(BLOOM_LAYER);

// subtle frame glow
const frameMat = new THREE.MeshStandardMaterial({
  color: COLORS.gold,
  metalness: 1.0,
  roughness: 0.30,
  emissive: COLORS.gold.clone().multiplyScalar(0.14),
  emissiveIntensity: 0.35,
  transparent:true,
  opacity: 0.85
});
const frame = new THREE.Mesh(new THREE.PlaneGeometry(2.75, 1.75), frameMat);
frame.position.z = -0.02;
videoGroup.add(frame);
frame.layers.enable(BLOOM_LAYER);

// caption as sprite
function makeCaptionTexture(text){
  const c = document.createElement("canvas");
  c.width = 1024; c.height = 256;
  const ctx = c.getContext("2d");

  ctx.clearRect(0,0,c.width,c.height);

  // backdrop gradient
  const g = ctx.createLinearGradient(0,0,c.width,0);
  g.addColorStop(0, "rgba(177,18,38,0.18)");
  g.addColorStop(0.5, "rgba(0,0,0,0.36)");
  g.addColorStop(1, "rgba(212,175,55,0.18)");
  ctx.fillStyle = g;
  roundRect(ctx, 40, 52, c.width-80, c.height-104, 42);
  ctx.fill();

  ctx.lineWidth = 4;
  ctx.strokeStyle = "rgba(212,175,55,0.55)";
  ctx.stroke();

  ctx.font = `900 92px "PingFang SC","Microsoft YaHei",ui-sans-serif`;
  ctx.textAlign="center";
  ctx.textBaseline="middle";

  // glow
  ctx.shadowColor="rgba(212,175,55,.60)";
  ctx.shadowBlur=18;
  ctx.fillStyle="rgba(245,215,122,0.98)";
  ctx.fillText(text, c.width/2, c.height/2 + 4);

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
}

let captionMesh = null;
function setCaption(text){
  const tex = makeCaptionTexture(text);
  if(captionMesh){
    captionMesh.material.map.dispose?.();
    captionMesh.material.map = tex;
    captionMesh.material.needsUpdate = true;
    return;
  }
  const mat = new THREE.SpriteMaterial({
    map: tex,
    transparent:true,
    opacity: 1.0,
    depthWrite:false,
    blending: THREE.AdditiveBlending,
    toneMapped:false
  });
  captionMesh = new THREE.Sprite(mat);
  captionMesh.scale.set(3.15, 0.78, 1);
  captionMesh.position.set(0, -1.25, 0.02);
  videoGroup.add(captionMesh);
  captionMesh.layers.enable(BLOOM_LAYER);
}

// reveal flow state
let revealPhase = 0; // 0 idle, 1 fly-in, 2 open, 3 show video
let revealT = 0;
let chosenIdiom = "";
let chosenVideo = "";

async function playRandomVideo(){
  chosenVideo = randPick(VIDEO_LIST);
  try{
    videoEl.pause();
    videoEl.src = chosenVideo;
    videoEl.load();
    await videoEl.play();
    return true;
  }catch(e){
    // fallback: show a placeholder by drawing on video plane via canvas
    return false;
  }
}

function beginReveal(){
  // only allow from SCATTER or REVEAL (re-roll)
  if(mode===Mode.COHESION) return;

  chosenIdiom = randPick(IDIOMS);
  focusTitleEl.textContent = "红包开封";
  focusTextEl.textContent = "正在为你抽取马年祝福…";

  setMode(Mode.REVEAL);

  // select a random envelope index
  const pick = Math.floor(Math.random()*ENVELOPE_COUNT);
  const p = envScatter[pick];

  // place grabGroup at that envelope position first
  grabGroup.position.copy(p);
  grabGroup.quaternion.copy(camera.quaternion);
  grabGroup.visible = true;

  // reset animation
  revealPhase = 1;
  revealT = 0;
  grabGroup.scale.setScalar(0.18); // start small (as picked in space)
  grabFlap.rotation.x = 0;
  videoGroup.visible = false;

  // slight camera highlight
  statusText.textContent = "抓到红包：正在放大…";
}

async function switchToVideoStage(){
  // ensure video loaded
  const ok = await playRandomVideo();

  // show caption and overlay text
  setCaption(chosenIdiom);
  focusTitleEl.textContent = "马年祝福";
  focusTextEl.textContent = ok
    ? `【${chosenIdiom}】\n祝你马年金光万丈，福运连连。`
    : `【${chosenIdiom}】\n未找到视频文件：请将马视频放到 assets/videos/ 目录。`;

  // position videoGroup in front of camera
  videoGroup.visible = true;
  const fwd = new THREE.Vector3();
  camera.getWorldDirection(fwd);

  const pos = camera.position.clone().addScaledVector(fwd, 6.2);
  videoGroup.position.copy(pos);
  videoGroup.quaternion.copy(camera.quaternion);

  statusText.textContent = "开封完成：播放马视频（再次三指抓可换一个红包）。";
}

/* ---------------------------
   Fireworks (彩色烟花粒子)
--------------------------- */
class Fireworks {
  constructor(maxBursts=10){
    this.maxBursts = maxBursts;
    this.bursts = [];
    this.group = new THREE.Group();
    scene.add(this.group);

    this.mat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      blending:THREE.AdditiveBlending,
      uniforms:{ uTime:{ value:0 } },
      vertexShader:`
        uniform float uTime;
        attribute vec3 position;
        attribute vec3 aVel;
        attribute vec3 aCol;
        attribute float aSeed;
        attribute float aLife;
        varying vec3 vCol;
        varying float vA;

        void main(){
          float t = uTime - aSeed;
          float life = aLife;
          float k = clamp(t / life, 0.0, 1.0);

          vec3 p = position + aVel * (t*1.25) + vec3(0.0, -0.7, 0.0) * (t*t*0.30);
          vCol = aCol;

          // fade
          vA = (1.0 - k) * smoothstep(0.0, 0.12, k);

          vec4 mv = modelViewMatrix * vec4(p,1.0);
          gl_Position = projectionMatrix * mv;

          float dist = max(0.001, -mv.z);
          gl_PointSize = clamp((2.0 + 6.0*(1.0-k)) * (180.0/dist), 1.0, 7.0);
        }
      `,
      fragmentShader:`
        precision highp float;
        varying vec3 vCol;
        varying float vA;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          float core = smoothstep(0.25, 0.0, d);
          float halo = smoothstep(0.60, 0.18, d) * 0.45;
          float a = (core + halo) * vA;
          if(a < 0.01) discard;
          gl_FragColor = vec4(vCol * (1.10 + 0.80*halo), a);
        }
      `
    });
  }

  spawnBurst(origin){
    if(this.bursts.length >= this.maxBursts){
      const old = this.bursts.shift();
      this.group.remove(old.points);
      old.geo.dispose();
      old.points.material.dispose();
    }

    const COUNT = IS_MOBILE ? 260 : 420;
    const geo = new THREE.BufferGeometry();
    const pos = new Float32Array(COUNT*3);
    const vel = new Float32Array(COUNT*3);
    const col = new Float32Array(COUNT*3);
    const seed = new Float32Array(COUNT);
    const life = new Float32Array(COUNT);

    const now = perfTime;
    for(let i=0;i<COUNT;i++){
      pos[i*3+0]=origin.x;
      pos[i*3+1]=origin.y;
      pos[i*3+2]=origin.z;

      const u=Math.random(), v=Math.random();
      const theta=u*Math.PI*2;
      const phi=Math.acos(2*v-1);
      const sp= 1.2 + Math.random()*2.4;
      vel[i*3+0]=Math.sin(phi)*Math.cos(theta)*sp;
      vel[i*3+1]=Math.cos(phi)*sp * 0.9;
      vel[i*3+2]=Math.sin(phi)*Math.sin(theta)*sp;

      const h = Math.random();
      const c = new THREE.Color().setHSL(h, 0.95, 0.60);
      col[i*3+0]=c.r;
      col[i*3+1]=c.g;
      col[i*3+2]=c.b;

      seed[i]=now + Math.random()*0.06;
      life[i]= 0.95 + Math.random()*0.55;
    }

    geo.setAttribute("position", new THREE.BufferAttribute(pos,3));
    geo.setAttribute("aVel", new THREE.BufferAttribute(vel,3));
    geo.setAttribute("aCol", new THREE.BufferAttribute(col,3));
    geo.setAttribute("aSeed", new THREE.BufferAttribute(seed,1));
    geo.setAttribute("aLife", new THREE.BufferAttribute(life,1));

    const points = new THREE.Points(geo, this.mat.clone());
    points.layers.enable(BLOOM_LAYER);
    this.group.add(points);

    this.bursts.push({ geo, points, born: now, ttl: 2.2 });
  }

  update(time){
    // update uniform
    for(const b of this.bursts){
      b.points.material.uniforms.uTime.value = time;
    }
    // cull expired
    for(let i=this.bursts.length-1;i>=0;i--){
      const b=this.bursts[i];
      if(time - b.born > b.ttl){
        this.group.remove(b.points);
        b.geo.dispose();
        b.points.material.dispose();
        this.bursts.splice(i,1);
      }
    }
  }
}
const fireworks = new Fireworks(IS_MOBILE ? 7 : 10);

/* ---------------------------
   Camera Control (scatter rotate)
--------------------------- */
let yaw = 0.0, pitch = 0.14, radius = 10.6;
let yawT = yaw, pitchT = pitch;

let lastPalmX=null, lastPalmY=null;

function applyCamera(dt){
  // COHESION: slow cinematic orbit
  if(mode===Mode.COHESION){
    yawT += dt * 0.16;
    pitchT = damp(pitchT, 0.12, 2.6, dt);
  } else if(mode===Mode.SCATTER){
    pitchT = clamp(pitchT, -0.18, 0.62);
  } else if(mode===Mode.REVEAL){
    pitchT = damp(pitchT, 0.14, 3.0, dt);
  }

  yaw = damp(yaw, yawT, 6.0, dt);
  pitch = damp(pitch, pitchT, 6.0, dt);

  const r = radius;
  const cx = Math.sin(yaw) * Math.cos(pitch) * r;
  const cy = 2.25 + Math.sin(pitch) * r * 0.30;
  const cz = Math.cos(yaw) * Math.cos(pitch) * r;

  camera.position.set(cx, cy, cz);
  camera.lookAt(0, 2.35, 0);

  goldPoint.position.set(
    Math.sin(yaw*0.7)*1.8,
    4.4 + Math.sin(perfTime*0.7)*0.12,
    2.0 + Math.cos(yaw*0.7)*1.2
  );
}

/* ---------------------------
   Music
--------------------------- */
let musicEnabled=false, musicPrepared=false;
async function enableMusic(){
  try{
    if(!musicPrepared){
      bgm.src=BGM_URL;
      bgm.load();
      musicPrepared=true;
    }
    bgm.volume=0.28;
    await bgm.play();
    musicEnabled=true;
    btnMusic.textContent="音乐：开";
  }catch(e){
    statusText.textContent="浏览器阻止自动播放：请再次点击“音乐”开启。";
    musicEnabled=false;
    btnMusic.textContent="音乐：关";
  }
}
function disableMusic(){
  bgm.pause();
  musicEnabled=false;
  btnMusic.textContent="音乐：关";
}
btnMusic.addEventListener("click", ()=>{ musicEnabled?disableMusic():enableMusic(); });

/* ---------------------------
   MediaPipe Hands Gestures
   - 握拳：COHESION（并随机换成语）
   - 张开：SCATTER
   - 掌心移动：SCATTER旋转相机
   - 三指抓：抓红包 → REVEAL
--------------------------- */
let hands=null;
let handEnabled=false;
let lastLandmarks=null;
let lastLandmarksTs=0;

function dist3(a,b){
  const dx=a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0);
  return Math.sqrt(dx*dx+dy*dy+dz*dz);
}
function extended(lm, tip, pip, wristIndex=0){
  const wrist = lm[wristIndex];
  const dt = dist3(lm[tip], wrist);
  const dp = dist3(lm[pip], wrist);
  return dt > dp*1.12;
}

function computeGesture(lm){
  // palm center
  const palmIdx=[0,5,9,13,17];
  const palm={x:0,y:0,z:0};
  for(const i of palmIdx){ palm.x+=lm[i].x; palm.y+=lm[i].y; palm.z+=lm[i].z; }
  palm.x/=palmIdx.length; palm.y/=palmIdx.length; palm.z/=palmIdx.length;

  const wrist = lm[0];
  const handSize = Math.max(1e-6, dist3(wrist, lm[9]));

  const thumbExt  = extended(lm,4,2);
  const indexExt  = extended(lm,8,6);
  const middleExt = extended(lm,12,10);
  const ringExt   = extended(lm,16,14);
  const pinkyExt  = extended(lm,20,18);

  const extCount = [thumbExt,indexExt,middleExt,ringExt,pinkyExt].filter(Boolean).length;

  const openHand = extCount>=4;

  // fist: most fingers not extended and tips close to palm
  const tips=[4,8,12,16,20];
  let avg=0;
  for(const t of tips) avg += dist3(lm[t], palm);
  avg/=tips.length;
  const closeHand = (extCount<=1) && (avg/handSize < 0.92);

  // 三指抓：拇指-食指 和 拇指-中指都靠近；同时无名指/小指更倾向收起
  const pinchTI = (dist3(lm[4], lm[8]) / handSize) < 0.35;
  const pinchTM = (dist3(lm[4], lm[12]) / handSize) < 0.38;
  const threeGrab = pinchTI && pinchTM && !ringExt && !pinkyExt;

  return { palm, openHand, closeHand, threeGrab };
}

let grabDown=false;
let grabCooldown=0;

function handleGesture(g, dt){
  // Mode switching
  if(g.openHand && mode!==Mode.REVEAL) setMode(Mode.SCATTER);
  if(g.closeHand) setMode(Mode.COHESION);

  // scatter rotate
  if(mode===Mode.SCATTER && !g.threeGrab && !g.closeHand){
    const x=g.palm.x, y=g.palm.y;
    if(lastPalmX!=null){
      const dx = x-lastPalmX;
      const dy = y-lastPalmY;
      yawT += (-dx)*4.2;
      pitchT += ( dy)*3.0;
    }
    lastPalmX=x; lastPalmY=y;
  }else{
    lastPalmX=lastPalmY=null;
  }

  // grab trigger
  grabCooldown = Math.max(0, grabCooldown-dt);
  const pressed = g.threeGrab && grabCooldown<=0;

  if(pressed && !grabDown){
    grabDown=true;
    // in scatter or reveal -> begin (or reroll)
    beginReveal();
    grabCooldown = 0.55;
  }
  if(!g.threeGrab) grabDown=false;
}

async function startHands(){
  if(!window.Hands){
    statusText.textContent="MediaPipe Hands 未加载：请检查网络。";
    return;
  }
  if(!navigator.mediaDevices?.getUserMedia){
    statusText.textContent="当前浏览器不支持摄像头 API。";
    return;
  }

  hands = new window.Hands({
    locateFile: (file)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
  });
  hands.onResults((res)=>{
    const lm = res.multiHandLandmarks?.[0] || null;
    if(lm){
      lastLandmarks=lm;
      lastLandmarksTs=performance.now();
    }
  });

  const stream = await navigator.mediaDevices.getUserMedia({
    audio:false,
    video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} }
  });
  camVideoEl.srcObject = stream;
  await camVideoEl.play();

  handEnabled=true;
  led.classList.add("on");
  statusText.textContent="手势已启用：握拳/张开/旋转/三指抓红包。";

  let busy=false;
  let lastSent=0;
  async function pump(){
    if(!handEnabled) return;
    const now=performance.now();
    if(!busy && (now-lastSent)>33){
      busy=true;
      lastSent=now;
      try{ await hands.send({ image: camVideoEl }); }catch(e){}
      busy=false;
    }
    requestAnimationFrame(pump);
  }
  pump();
}

btnStart.addEventListener("click", async ()=>{
  try{
    btnStart.disabled=true;
    btnStart.textContent="正在启用…";
    await startHands();
    btnStart.textContent="手势：已开启";
  }catch(e){
    statusText.textContent="启用失败：请允许摄像头权限，并确保在 HTTPS（GitHub Pages）访问。";
    btnStart.disabled=false;
    btnStart.textContent="启用手势";
  }
});

/* ---------------------------
   Mouse fallback (double click to grab)
--------------------------- */
let dragging=false, lastX=0, lastY=0;
let lastTap=0;

canvas.addEventListener("pointerdown",(e)=>{
  dragging=true; lastX=e.clientX; lastY=e.clientY;
});
window.addEventListener("pointerup",()=>dragging=false);
window.addEventListener("pointermove",(e)=>{
  if(!dragging) return;
  if(mode!==Mode.SCATTER) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY;
  lastX=e.clientX; lastY=e.clientY;
  yawT += dx*0.0042;
  pitchT += dy*0.0032;
});
canvas.addEventListener("click",()=>{
  const now=performance.now();
  if(now-lastTap<360){
    // double click -> reveal
    if(mode===Mode.SCATTER || mode===Mode.REVEAL) beginReveal();
  }
  lastTap=now;
});

/* ---------------------------
   UI actions
--------------------------- */
btnHelp.addEventListener("click", ()=>{
  tips.style.display = (tips.style.display==="none") ? "flex" : "none";
});

btnReset.addEventListener("click", ()=>{
  // reset scatter positions
  for(let i=0;i<ENVELOPE_COUNT;i++) envScatter[i] = sampleScatterSphere();
  pickNewIdiom(true);

  // mode reset
  revealPhase=0; revealT=0;
  grabGroup.visible=false;
  videoGroup.visible=false;
  try{ videoEl.pause(); }catch(e){}
  setMode(Mode.COHESION);
});

/* ---------------------------
   Background mood updates
--------------------------- */
function updateMood(dt){
  const f = (mode===Mode.REVEAL) ? 1 : 0;
  const s = (mode===Mode.SCATTER) ? 1 : 0;

  bloomPass.strength  = damp(bloomPass.strength, 1.14 + 0.10*s + 0.18*f, 2.8, dt);
  bloomPass.radius    = damp(bloomPass.radius,   0.60 + 0.05*s + 0.10*f, 2.8, dt);
  bloomPass.threshold = damp(bloomPass.threshold,0.16 - 0.01*s - 0.03*f, 2.8, dt);

  renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.06 + 0.02*s + 0.06*f, 2.4, dt);

  // bloom mix: in reveal, slightly reduce base bloom to keep video/caption crisp
  bloomMixPass.material.uniforms.uBloomIntensity.value = lerp(1.0, 0.55, reveal);
}

/* ---------------------------
   Main render loop
--------------------------- */
let lastTime=performance.now();
let perfTime=0;
let fireworkCooldown=0;

setMode(Mode.COHESION);

function animate(){
  const now=performance.now();
  const dt = clamp((now-lastTime)/1000, 0.0, 0.035);
  lastTime=now;
  perfTime += dt;

  // hand gestures
  if(handEnabled && lastLandmarks && (now-lastLandmarksTs)<180){
    const g=computeGesture(lastLandmarks);
    handleGesture(g, dt);
  }

  // smooth transitions
  mix = damp(mix, targetMix, 2.8, dt);
  reveal = damp(reveal, targetReveal, 4.2, dt);

  // update idiom
  idiomMat.uniforms.uTime.value = perfTime;
  idiomMat.uniforms.uMix.value = mix;
  idiomMat.uniforms.uFocus.value = reveal;

  // envelopes
  updateEnvelopes(perfTime, mix, reveal, dt);

  // camera
  applyCamera(dt);

  // reveal animation (红包抓取→放大→开封→视频)
  if(mode===Mode.REVEAL){
    // keep idiomGroup slightly dim in reveal so fireworks/video stand out
    idiomGroup.scale.setScalar(lerp(1.0, 1.02, reveal));

    // animate grabGroup in front of camera
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    const targetPos = camera.position.clone().addScaledVector(fwd, 5.6);

    if(revealPhase===1){
      // fly-in + scale up
      revealT += dt;
      const t = clamp(revealT/0.55, 0, 1);
      grabGroup.position.lerp(targetPos, 0.10 + 0.35*t);
      grabGroup.quaternion.slerp(camera.quaternion, 0.12 + 0.28*t);

      const sc = lerp(0.18, 1.0, smoothstep(0,1,t));
      grabGroup.scale.setScalar(sc);

      // small sway
      grabGroup.position.add(new THREE.Vector3(
        Math.sin(perfTime*2.0)*0.03,
        Math.cos(perfTime*1.7)*0.02,
        0
      ).applyQuaternion(camera.quaternion));

      if(t>=1){
        revealPhase=2;
        revealT=0;
        statusText.textContent="红包开封中…";
        focusTextEl.textContent="红包开封中…";
      }
    }else if(revealPhase===2){
      // open flap
      revealT += dt;
      const t = clamp(revealT/0.60, 0, 1);
      const ease = smoothstep(0,1,t);

      // flap rotates backward
      grabFlap.rotation.x = -ease * 1.35;

      // stamp pulses
      grabStamp.scale.setScalar(1.0 + Math.sin(perfTime*6.0)*0.02);

      if(t>=1){
        revealPhase=3;
        revealT=0;
        grabGroup.visible = false; // envelope "disappears into blessing"
        switchToVideoStage();
      }
    }else if(revealPhase===3){
      // keep video in front of camera; slight breathing
      if(videoGroup.visible){
        const fwd2 = new THREE.Vector3();
        camera.getWorldDirection(fwd2);
        const pos = camera.position.clone().addScaledVector(fwd2, 6.2);
        videoGroup.position.lerp(pos, 0.12);
        videoGroup.quaternion.slerp(camera.quaternion, 0.12);

        const breathe = 1.0 + Math.sin(perfTime*1.2)*0.01;
        videoGroup.scale.setScalar(breathe);
      }

      // fireworks spawn loop in reveal
      fireworkCooldown = Math.max(0, fireworkCooldown-dt);
      if(fireworkCooldown<=0){
        const u = Math.random()*2-1;
        const v = Math.random()*0.7 + 0.1;
        const origin = new THREE.Vector3(u*3.2, 3.0+v*2.2, -3.0 + Math.random()*2.0);
        fireworks.spawnBurst(origin);
        fireworkCooldown = IS_MOBILE ? (0.85 + Math.random()*0.35) : (0.65 + Math.random()*0.28);
      }
    }
  }else{
    // not reveal
    grabGroup.visible = false;
    videoGroup.visible = false;
  }

  fireworks.update(perfTime);

  // mood
  updateMood(dt);

  // render selective bloom
  camera.layers.set(BLOOM_LAYER);
  bloomComposer.render();
  camera.layers.set(0);
  finalComposer.render();

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

function smoothstep(a,b,t){
  t = clamp((t-a)/(b-a), 0, 1);
  return t*t*(3.0-2.0*t);
}

/* ---------------------------
   Resize
--------------------------- */
function onResize(){
  const w=window.innerWidth, h=window.innerHeight;
  camera.aspect=w/h;
  camera.updateProjectionMatrix();
  renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio||1));
  renderer.setSize(w,h,false);
  bloomComposer.setSize(w,h);
  finalComposer.setSize(w,h);
  bloomPass.setSize?.(w,h);
}
window.addEventListener("resize", onResize);

// initial hint
statusText.textContent = "点击“启用手势”开始。握拳：合拢成语；张开：散开漂浮；三指抓：抓红包开封。";
</script>
</body>
</html>
