<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>马年祝福 · 手势粒子成语 · 红包开封 · 烟花背景</title>

  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <script type="importmap-shim">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --gold:#d4af37;
      --red:#b11226;
      --panel: rgba(10,10,12,.58);
      --panel2: rgba(4,6,9,.42);
      --line: rgba(212,175,55,.35);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
    }
    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(120% 120% at 50% 30%, #14060a 0%, #070607 55%, #040405 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }
    #app{ position:fixed; inset:0; }
    canvas#gl{ position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; }

    .cinema-vignette{
      position:absolute; inset:0; pointer-events:none;
      background:
        radial-gradient(120% 120% at 50% 45%, rgba(0,0,0,0) 42%, rgba(0,0,0,.62) 100%),
        radial-gradient(90% 70% at 50% 0%, rgba(212,175,55,.14) 0%, rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(177,18,38,.12) 0%, rgba(0,0,0,0) 40%);
      mix-blend-mode:screen;
      opacity:.95;
    }
    .film-grain{
      position:absolute; inset:-20%;
      pointer-events:none;
      background-image:
        repeating-linear-gradient(0deg, rgba(255,255,255,.025) 0 1px, rgba(0,0,0,0) 1px 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.018) 0 1px, rgba(0,0,0,0) 1px 4px);
      opacity:.22;
      transform:rotate(2deg);
      animation: grain 7s linear infinite;
      mix-blend-mode:overlay;
      filter: blur(.2px);
    }
    @keyframes grain{
      0%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
      50%{ transform:translate3d(2%, 1%, 0) rotate(2deg); }
      100%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
    }

    .hud{
      position:absolute; left:12px; right:12px; top:12px;
      display:flex; gap:10px; align-items:flex-start;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      flex:1 1 auto;
      max-width:980px;
      padding:12px 12px 10px;
      border:1px solid var(--line);
      border-radius:14px;
      background:linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .brand{ display:flex; gap:10px; align-items:center; min-width:320px; }
    .badge{
      width:12px; height:12px; border-radius:999px;
      background: var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.18), 0 0 18px rgba(212,175,55,.45);
    }
    .title{ font-weight:800; letter-spacing:.3px; font-size:14px; line-height:1.2; }
    .subtitle{ font-size:12px; color:var(--muted); margin-top:2px; }

    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-left:auto; }

    button{
      pointer-events:auto;
      appearance:none;
      border:1px solid rgba(212,175,55,.38);
      color:var(--text);
      background:linear-gradient(180deg, rgba(177,18,38,.35), rgba(0,0,0,.22));
      border-radius:12px;
      padding:10px 12px;
      font-size:12px;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
      user-select:none;
    }
    button.secondary{
      border-color: rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.18));
      color: rgba(255,255,255,.86);
    }

    .status{
      margin-left:auto;
      font-size:12px;
      color:rgba(255,255,255,.70);
      display:flex; align-items:center; gap:8px;
    }
    .led{
      width:8px; height:8px; border-radius:999px;
      background: rgba(255,255,255,.18);
      box-shadow:0 0 0 2px rgba(255,255,255,.06);
    }
    .led.on{
      background: var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.16), 0 0 16px rgba(212,175,55,.55);
    }

    .focusOverlay{
      position:absolute; inset:0;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding:16px 12px 22px;
      pointer-events:none;
      opacity:0;
      transform: translate3d(0, 10px, 0);
      transition: opacity .25s ease, transform .25s ease;
    }
    .focusOverlay.show{
      opacity:1;
      transform: translate3d(0,0,0);
    }
    .focusCard{
      pointer-events:auto;
      width:min(860px, calc(100vw - 24px));
      border-radius:18px;
      border:1px solid rgba(212,175,55,.45);
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(8,10,12,.66));
      box-shadow: 0 22px 70px rgba(0,0,0,.62);
      backdrop-filter: blur(12px);
      padding:14px 14px 12px;
      position:relative;
      overflow:hidden;
    }
    .focusTop{
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
      position:relative;
    }
    .focusAvatar{
      width:72px;
      height:72px;
      border-radius:999px;
      object-fit:cover;
      border:1px solid rgba(212,175,55,.55);
      box-shadow:0 0 18px rgba(0,0,0,.6);
      overflow:hidden;
      flex:0 0 auto;
      display:none;
    }
    .packet{
      width:150px;
      height:190px;
      border-radius:16px;
      background: linear-gradient(180deg, rgba(177,18,38,.98), rgba(120,8,22,.98));
      border:1px solid rgba(212,175,55,.55);
      box-shadow: 0 18px 55px rgba(0,0,0,.6);
      position:relative;
      overflow:hidden;
      transform-origin: 50% 0%;
    }
    .packet .seal{
      position:absolute;
      left:50%; top:54%;
      width:62px; height:62px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,245,220,.95), rgba(212,175,55,.92) 60%, rgba(90,60,10,.85) 100%);
      box-shadow: 0 0 0 2px rgba(212,175,55,.20), 0 0 26px rgba(212,175,55,.45);
    }
    .packet .seal::after{
      content:attr(data-glyph);
      position:absolute;
      left:50%; top:50%;
      transform:translate(-50%,-52%);
      font-size:32px;
      font-weight:900;
      color:rgba(140,10,30,.98);
      text-shadow:0 2px 4px rgba(0,0,0,.35);
    }
    .packet .lid{
      position:absolute;
      left:0; top:0;
      width:100%; height:52%;
      background: linear-gradient(180deg, rgba(215,30,55,.98), rgba(140,10,30,.98));
      border-bottom:1px solid rgba(212,175,55,.35);
      transform-origin: 50% 100%;
      transform: rotateX(0deg);
    }
    .packet.open .lid{ animation: openLid .55s ease forwards; }
    @keyframes openLid{
      0%{ transform: rotateX(0deg); }
      100%{ transform: rotateX(-125deg); }
    }

    .focusTextWrap{ flex:1 1 320px; min-width:260px; }
    .focusTitle{ margin:0; font-size:15px; letter-spacing:.5px; font-weight:900; }
    .focusLine{ margin:8px 0 0; font-size:14px; line-height:1.6; color: rgba(255,255,255,.88); white-space:pre-wrap; }

    .videoWrap{
      margin-top:12px;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      position:relative;
      box-shadow: 0 16px 46px rgba(0,0,0,.55);
    }
    .videoWrap video{ width:100%; height:auto; display:block; background:#000; }

    video#cam{
      position:absolute;
      right:12px; bottom:12px;
      width:120px; height:160px;
      opacity:0;
      pointer-events:none;
    }
  </style>
</head>

<body>
<div id="app">
  <canvas id="gl"></canvas>
  <div class="cinema-vignette"></div>
  <div class="film-grain"></div>

  <div class="hud">
    <div class="panel">
      <div class="row">
        <div class="brand">
          <span class="badge"></span>
          <div>
            <div class="title">马年祝福 · 手势粒子成语 · 红包开封 · 烟花背景</div>
            <div class="subtitle">握拳：凝聚成语；张开：散开湍流 + 马视频；三指捏合：抓红包</div>
          </div>
        </div>

        <div class="controls">
          <button id="btnStart">启用手势识别</button>
          <button id="btnReset" class="secondary">重置</button>
        </div>

        <div class="status">
          <span id="led" class="led"></span>
          <span id="statusText">已加载：凝聚态（稳定成语 + 红包环绕）</span>
        </div>
      </div>
    </div>
  </div>

  <div id="focusOverlay" class="focusOverlay">
    <div class="focusCard">
      <div class="focusTop">
        <div id="packet" class="packet">
          <div class="lid"></div>
          <div class="seal" data-glyph="福"></div>
        </div>
        <img id="focusAvatar" class="focusAvatar" alt="">
        <div class="focusTextWrap">
          <h3 id="focusTitle" class="focusTitle">红包到 · 好运到</h3>
          <div id="focusText" class="focusLine"></div>
        </div>
      </div>

      <div class="videoWrap" id="rewardVideoWrap">
        <video id="horseVideo" playsinline muted loop></video>
      </div>
    </div>
  </div>

  <video id="cam" playsinline></video>
  <audio id="bgm" src="assets/music/gongxifacai.mp3" loop></audio>
</div>

<script type="module-shim">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

const IDIOMS = [
  "马到成功","龙马精神","一马当先","万马奔腾","马上发财","马上如意",
  "策马扬鞭","快马加鞭","一马平川","天马行空","马到功成","马跃钱程",
  "人强马壮","金戈铁马","骏马奔腾","马蹄生风",
  "马年大吉","金马迎春","马到财来","马到福来","马到运来","马力全开"
];

const HORSE_VIDEOS = [
  "assets/videos/horse1.mp4",
  "assets/videos/horse2.mp4",
  "assets/videos/horse3.mp4",
  "assets/videos/horse4.mp4"
];

// 散开态马视频（webm）
const HORSE_RUN_WEBM = "assets/video/horse.webm";

const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const DPR_CAP = IS_MOBILE ? 1.15 : 1.9;
const BLOOM_SCALE = IS_MOBILE ? 0.55 : 0.70;

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp  = (a,b,t)=>a+(b-a)*t;
const damp = (current, target, lambda, dt) => {
  const t = 1 - Math.exp(-lambda * dt);
  return current + (target - current) * t;
};

const canvas = document.getElementById("gl");
const statusText = document.getElementById("statusText");
const led = document.getElementById("led");
const btnStart = document.getElementById("btnStart");
const btnReset = document.getElementById("btnReset");
const videoEl = document.getElementById("cam");
const bgmEl = document.getElementById("bgm");

const focusOverlay = document.getElementById("focusOverlay");
const focusTitleEl = document.getElementById("focusTitle");
const focusTextEl = document.getElementById("focusText");
const packetEl = document.getElementById("packet");
const packetLidEl = packetEl?.querySelector(".lid");
const packetSealEl = packetEl?.querySelector(".seal");
const horseVideo = document.getElementById("horseVideo");
const focusAvatarEl = document.getElementById("focusAvatar");
const rewardVideoWrap = document.getElementById("rewardVideoWrap");
let bgmStarted = false;

// ---------------------------
// Three.js 基础
// ---------------------------
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
  alpha: false,
  powerPreference: "high-performance"
});
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.06;

const scene = new THREE.Scene();
scene.background = new THREE.Color("#030304");

const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0, 2.3, 10.4);

scene.add(new THREE.AmbientLight(0xffffff, 0.18));
const key = new THREE.DirectionalLight(0xfff2d6, 0.98);
key.position.set(6, 9, 6);
scene.add(key);

const goldPoint = new THREE.PointLight(0xd4af37, 1.2, 26, 2);
goldPoint.position.set(0, 5.2, 3.2);
scene.add(goldPoint);

// ---------------------------
// 后期辉光（Bloom）
// ---------------------------
const BLOOM_LAYER = 1;

const bloomComposer = new EffectComposer(renderer);
bloomComposer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.05, 0.62, 0.16);
bloomComposer.addPass(bloomPass);

const finalComposer = new EffectComposer(renderer);
finalComposer.addPass(new RenderPass(scene, camera));

const bloomMixPass = new ShaderPass(
  new THREE.ShaderMaterial({
    uniforms: {
      baseTexture: { value: null },
      bloomTexture: { value: bloomComposer.renderTarget2.texture },
      uBloomIntensity: { value: 0.95 }
    },
    vertexShader: `
      varying vec2 vUv;
      void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }
    `,
    fragmentShader: `
      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;
      uniform float uBloomIntensity;
      varying vec2 vUv;
      void main(){
        vec4 base = texture2D(baseTexture, vUv);
        vec4 bloom = texture2D(bloomTexture, vUv);
        gl_FragColor = base + bloom * uBloomIntensity;
      }
    `
  }),
  "baseTexture"
);
finalComposer.addPass(bloomMixPass);
finalComposer.addPass(new OutputPass());

// ---------------------------
// 模式 & 过渡
// ---------------------------
const Mode = { MERGE:"MERGE", SCATTER:"SCATTER", FOCUS:"FOCUS" };
let mode = Mode.MERGE;

let mix = 0;        // 0:凝聚  1:散开
let targetMix = 0;

let focus = 0;      // 0:正常  1:聚焦红包卡片
let targetFocus = 0;

// ✅ 固定成语：每次"张开->握拳"只选一次，握拳期间不会闪烁切换
// 初始显示 "HAPPY NEW YEAR"，手势识别成功后切换为 IDIOMS 中的成语
let selectedIdiom = "HAPPY NEW YEAR";
let hasSwitchedToIdioms = false;  // 是否已切换到成语
let cycleLocked = true;            // 初始为凝聚态，锁定成语
let closeHoldSec = 0;              // 握拳持续时间（去抖）
let openHoldSec = 0;               // 张开持续时间（去抖）
let mergeCooldownSec = 0;          // 防止短时间重复触发
let mergeBoost = 0;                // 凝聚阶段加速成型

function setMode(next){
  if(mode === next) return;
  mode = next;

  if(mode === Mode.MERGE){
    targetMix = 0;
    targetFocus = 0;
    hideFocusOverlay();
    setHorseScatterVisible(false);
  }else if(mode === Mode.SCATTER){
    targetMix = 1;
    targetFocus = 0;
    hideFocusOverlay();
    setHorseScatterVisible(true);
    kickScatterImpulse();
  }else{
    targetMix = 1;
    targetFocus = 1;
    showFocusOverlay();
    setHorseScatterVisible(false);
  }
}
function showFocusOverlay(){ focusOverlay.classList.add("show"); }
function hideFocusOverlay(){ focusOverlay.classList.remove("show"); packetEl.classList.remove("open"); }

// ---------------------------
// 背景音乐（刘德华《恭喜发财》）
// ---------------------------
function tryStartBgm(){
  if(!bgmEl || bgmStarted) return;
  bgmStarted = true;
  try{
    bgmEl.volume = 0.45;
    bgmEl.loop = true;
    const p = bgmEl.play();
    if(p && typeof p.then === "function"){
      p.catch(()=>{ bgmStarted = false; });
    }
  }catch(e){
    bgmStarted = false;
  }
}

// ---------------------------
// 红包外观切换（福/默认）
// ---------------------------
const PACKET_GRADIENT = "linear-gradient(180deg, rgba(177,18,38,.98), rgba(120,8,22,.98))";
const LID_GRADIENT = "linear-gradient(180deg, rgba(215,30,55,.98), rgba(140,10,30,.98))";

function setPacketDefault(glyph="福"){
  if(packetEl){
    packetEl.style.background = PACKET_GRADIENT;
    packetEl.style.backgroundSize = "";
  }
  if(packetLidEl){
    packetLidEl.style.background = LID_GRADIENT;
  }
  if(packetSealEl){
    packetSealEl.setAttribute("data-glyph", glyph);
  }
}

function setPacketAvatarMode(avatarUrl, glyph="福"){
  if(packetEl){
    // 清除之前的背景渐变，使用头像作为背景
    packetEl.style.background = "none";
    packetEl.style.backgroundImage = `url(${avatarUrl})`;
    packetEl.style.backgroundSize = "cover";
    packetEl.style.backgroundPosition = "center";
    packetEl.style.backgroundRepeat = "no-repeat";
  }
  if(packetLidEl){
    // 盖子使用半透明背景，让头像可见
    packetLidEl.style.background = "rgba(0,0,0,0.35)";
  }
  if(packetSealEl){
    packetSealEl.setAttribute("data-glyph", glyph);
  }
}

// ---------------------------
// 员工祝福配置（从 assets/blesses.json 读取）
// ---------------------------
let blesses = [];
// 记录已经被抽中的员工ID
let drawnEmployeeIds = new Set();

(async function loadBlesses(){
  try{
    const res = await fetch("assets/blesses.json");
    if(!res.ok) throw new Error("failed");
    const data = await res.json();
    if(Array.isArray(data)) blesses = data;
  }catch(e){
    blesses = [];
  }
})();

// ---------------------------
// 点纹理（用于银河/火花）
// ---------------------------
function makeDotTexture(){
  const c = document.createElement("canvas");
  c.width = 128; c.height = 128;
  const ctx = c.getContext("2d");
  const g = ctx.createRadialGradient(64,64,0,64,64,64);
  g.addColorStop(0, "rgba(255,255,255,1)");
  g.addColorStop(0.22, "rgba(255,255,255,0.85)");
  g.addColorStop(0.55, "rgba(255,255,255,0.22)");
  g.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(64,64,62,0,Math.PI*2); ctx.fill();
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}
const DOT_TEX = makeDotTexture();

// ---------------------------
// 散开态：奔跑马视频（固定不抖动）
// ---------------------------
const horseRunVideo = document.createElement("video");
horseRunVideo.src = HORSE_RUN_WEBM;
horseRunVideo.muted = true;
horseRunVideo.loop = true;
horseRunVideo.playsInline = true;
horseRunVideo.preload = "auto";
horseRunVideo.crossOrigin = "anonymous";

let horseReady = false;
horseRunVideo.addEventListener("loadeddata", ()=>{ horseReady = true; }, { once:false });
horseRunVideo.addEventListener("canplay", ()=>{ horseReady = true; }, { once:false });

const horseRunTex = new THREE.VideoTexture(horseRunVideo);
horseRunTex.colorSpace = THREE.SRGBColorSpace;
horseRunTex.minFilter = THREE.LinearFilter;
horseRunTex.magFilter = THREE.LinearFilter;
horseRunTex.generateMipmaps = false;

const horseGroup = new THREE.Group();
horseGroup.visible = false;
scene.add(horseGroup);

const horsePlane = new THREE.Mesh(
  new THREE.PlaneGeometry(6.6, 3.8),
  new THREE.MeshBasicMaterial({
    map: horseRunTex,
    transparent: true,
    opacity: 0.96,
    depthWrite: false,
    depthTest: false,
    toneMapped: false
  })
);
// ✅ 视频应在“湍流之上”：renderOrder 在散开态设更高（见 animate 中动态设置）
horsePlane.renderOrder = 30000;
horsePlane.layers.enable(0);
horseGroup.add(horsePlane);

// ✅ 固定位置（不抖动）
horseGroup.position.set(0, 2.25, 0.65);

function updateHorseBillboard(){ horsePlane.quaternion.copy(camera.quaternion); }

function setHorseScatterVisible(v){
  if(v){
    horseGroup.visible = (horseReady || horseRunVideo.readyState >= 2);
    horseRunVideo.play().catch(()=>{});
  }else{
    horseGroup.visible = false;
    horseRunVideo.pause();
  }
}
async function warmupVideo(v){
  try{ await v.play(); v.pause(); }catch(e){}
}

// ---------------------------
// 银河星环（散开态显示，依然在整体上方）
// ---------------------------
class GalaxyRing {
  constructor(count = (IS_MOBILE ? 9000 : 16000)){
    this.count = count;
    this.pos = new Float32Array(count*3);
    this.seed= new Float32Array(count);
    this.baseR = new Float32Array(count);
    this.baseH = new Float32Array(count);
    this.baseA = new Float32Array(count);

    for(let i=0;i<count;i++){
      this.seed[i] = Math.random();
      this.baseR[i] = lerp(4.9, 8.8, Math.pow(Math.random(), 0.55));
      this.baseH[i] = (Math.random()-0.5) * lerp(0.25, 1.15, Math.random());
      this.baseA[i] = Math.random() * Math.PI * 2;
    }

    this.geo = new THREE.BufferGeometry();
    this.geo.setAttribute("position", new THREE.BufferAttribute(this.pos,3));

    this.mat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      depthTest:false,
      blending: THREE.AdditiveBlending,
      uniforms:{ uOpacity:{value:0}, uMap:{value:DOT_TEX} },
      vertexShader:`
        uniform float uOpacity;
        varying float vO;
        void main(){
          vO = uOpacity;
          vec4 mv = modelViewMatrix * vec4(position,1.0);
          gl_Position = projectionMatrix * mv;
          float dist = max(0.001, -mv.z);
          gl_PointSize = clamp(1.25*(170.0/dist), 0.55, 3.2);
        }
      `,
      fragmentShader:`
        precision highp float;
        uniform sampler2D uMap;
        varying float vO;
        void main(){
          vec4 m = texture2D(uMap, gl_PointCoord);
          if(m.a < 0.02) discard;
          vec3 warm = vec3(1.0, 0.95, 0.82);
          vec3 gold = vec3(0.86, 0.72, 0.26);
          float k = smoothstep(0.15, 0.95, m.a);
          vec3 col = mix(warm, gold, k*0.55);
          gl_FragColor = vec4(col, m.a * (0.55 + 0.45*k) * vO);
        }
      `
    });

    this.points = new THREE.Points(this.geo, this.mat);
    this.points.frustumCulled = false;
    this.points.renderOrder = 50000;
    this.points.layers.enable(0);
    this.points.layers.enable(BLOOM_LAYER);

    scene.add(this.points);
    this.center = new THREE.Vector3(0, 2.25, 0);
  }

  update(time, active01){
    this.mat.uniforms.uOpacity.value = active01;
    this.points.visible = active01 > 0.01;
    if(!this.points.visible) return;

    for(let i=0;i<this.count;i++){
      const seed = this.seed[i];
      const r = this.baseR[i];
      const h = this.baseH[i];
      const a0= this.baseA[i];
      const w = lerp(0.09, 0.24, (8.8 - r) / (8.8 - 4.9));
      const a = a0 + time * w + seed * 2.0;

      const turb = Math.sin(time*0.9 + seed*10.0) * 0.13;
      const rr = r + turb;

      this.pos[i*3+0] = this.center.x + Math.cos(a)*rr;
      this.pos[i*3+2] = this.center.z + Math.sin(a)*rr;
      this.pos[i*3+1] = this.center.y + h + Math.sin(time*0.65 + seed*12.0)*0.11;
    }
    this.geo.attributes.position.needsUpdate = true;
  }
}
const galaxy = new GalaxyRing();

// ---------------------------
// “马”字点精灵纹理（粒子材质用）
// ---------------------------
function makeMaGlyphTexture(){
  const c = document.createElement("canvas");
  c.width = 256; c.height = 256;
  const ctx = c.getContext("2d");
  ctx.clearRect(0,0,256,256);

  const g = ctx.createRadialGradient(128,128,0,128,128,118);
  g.addColorStop(0, "rgba(212,175,55,0.22)");
  g.addColorStop(0.65, "rgba(212,175,55,0.06)");
  g.addColorStop(1, "rgba(212,175,55,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,256,256);

  ctx.save();
  ctx.translate(128, 145);
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = "900 160px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.lineJoin = "round";
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(177,18,38,0.55)";
  ctx.strokeText("马", 0, 0);
  ctx.fillStyle = "rgba(255,245,220,0.92)";
  ctx.fillText("马", 0, 0);
  ctx.restore();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}
const MA_TEX = makeMaGlyphTexture();

// ---------------------------
// 成语采样：描边为主、填充为辅（轮廓清晰）
// ---------------------------
function sampleTextPointsStrokeFill(text, {
  fontSize = 190,
  worldWidth = 7.8,
  strokeStep = IS_MOBILE ? 4 : 3,
  fillStep   = IS_MOBILE ? 10 : 8,
  strokeThreshold = 12,
  fillThreshold   = 60,
  fillKeepProb    = 0.26
} = {}){
  const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d", { willReadFrequently: true });

  const font = `900 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
  ctx.font = font;
  const metrics = ctx.measureText(text);
  const pad = Math.ceil(fontSize * 0.55);
  const cssW = Math.ceil(metrics.width + pad * 2);
  const cssH = Math.ceil(fontSize * 1.38 + pad * 2);

  c.width  = Math.ceil(cssW * dpr);
  c.height = Math.ceil(cssH * dpr);

  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  ctx.font = font;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.lineJoin = "round";
  ctx.miterLimit = 2;

  const strokeW = Math.max(12, Math.round(fontSize*0.085));
  ctx.lineWidth = strokeW;
  ctx.strokeStyle = "rgba(255,255,255,1)";
  ctx.strokeText(text, cssW/2, cssH/2);
  const strokeData = ctx.getImageData(0,0,c.width,c.height).data;

  ctx.clearRect(0,0,cssW,cssH);
  ctx.font = font;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "rgba(255,255,255,1)";
  ctx.fillText(text, cssW/2, cssH/2);
  const fillData = ctx.getImageData(0,0,c.width,c.height).data;

  const pts = [];
  const scale = worldWidth / cssW;

  const strokeStepPx = Math.max(1, Math.round(strokeStep * dpr));
  const fillStepPx   = Math.max(1, Math.round(fillStep   * dpr));

  for(let y=0;y<c.height;y+=strokeStepPx){
    for(let x=0;x<c.width;x+=strokeStepPx){
      const a = strokeData[(y*c.width + x)*4 + 3];
      if(a > strokeThreshold){
        const xCss = x/dpr, yCss = y/dpr;
        const px = (xCss - cssW/2)*scale;
        const py = (cssH/2 - yCss)*scale;
        pts.push(px, py, 0);
      }
    }
  }

  for(let y=0;y<c.height;y+=fillStepPx){
    for(let x=0;x<c.width;x+=fillStepPx){
      const a = fillData[(y*c.width + x)*4 + 3];
      if(a > fillThreshold && Math.random() < fillKeepProb){
        const xCss = x/dpr, yCss = y/dpr;
        const px = (xCss - cssW/2)*scale;
        const py = (cssH/2 - yCss)*scale;
        pts.push(px, py, 0);
      }
    }
  }

  return new Float32Array(pts);
}

// ---------------------------
// 成语粒子系统
// ---------------------------
const idiomGroup = new THREE.Group();
idiomGroup.position.set(0, 2.25, 0);
scene.add(idiomGroup);

let envHomeRingR = 3.2;

const MAX_PARTICLES = IS_MOBILE ? 8500 : 14000;

const idiomGeo = new THREE.BufferGeometry();
const aPos = new Float32Array(MAX_PARTICLES*3);
const aVel = new Float32Array(MAX_PARTICLES*3);
const aTar = new Float32Array(MAX_PARTICLES*3);
const aSeed= new Float32Array(MAX_PARTICLES);

let activeCount = MAX_PARTICLES;

idiomGeo.setAttribute("position", new THREE.BufferAttribute(aPos, 3));
idiomGeo.setAttribute("aVel", new THREE.BufferAttribute(aVel, 3));
idiomGeo.setAttribute("aTar", new THREE.BufferAttribute(aTar, 3));
idiomGeo.setAttribute("aSeed", new THREE.BufferAttribute(aSeed,1));

for(let i=0;i<MAX_PARTICLES;i++){
  aPos[i*3+0]=(Math.random()-0.5)*6;
  aPos[i*3+1]=2+(Math.random()-0.5)*3;
  aPos[i*3+2]=(Math.random()-0.5)*6;

  aVel[i*3+0]=(Math.random()-0.5)*0.2;
  aVel[i*3+1]=(Math.random()-0.5)*0.2;
  aVel[i*3+2]=(Math.random()-0.5)*0.2;

  aTar[i*3+0]=0; aTar[i*3+1]=0; aTar[i*3+2]=0;
  aSeed[i]=Math.random();
}

function rebuildIdiomTargets(text){
  const pts = sampleTextPointsStrokeFill(text, {
    fontSize: 190,
    worldWidth: IS_MOBILE ? 7.0 : 7.9,
    strokeStep: IS_MOBILE ? 4 : 3,
    fillStep:   IS_MOBILE ? 10 : 8,
    fillKeepProb: IS_MOBILE ? 0.22 : 0.26
  });

  const targetN = Math.max(1, Math.floor(pts.length/3));
  activeCount = Math.min(MAX_PARTICLES, targetN);

  for(let i=0;i<activeCount;i++){
    const idx = i*3;
    const baseX = pts[idx+0];
    const baseY = pts[idx+1];

    const seed = aSeed[i];
    const z = (seed - 0.5) * (IS_MOBILE ? 0.45 : 0.62);
    const j = (seed - 0.5) * (IS_MOBILE ? 0.03 : 0.05);

    aTar[i*3+0] = baseX + j;
    aTar[i*3+1] = baseY - j;
    aTar[i*3+2] = z;
  }

  for(let i=activeCount;i<MAX_PARTICLES;i++){
    aTar[i*3+0] = 999;
    aTar[i*3+1] = 999;
    aTar[i*3+2] = 999;
  }

  idiomGeo.setDrawRange(0, activeCount);
  idiomGeo.attributes.aTar.needsUpdate = true;
  idiomGeo.computeBoundingSphere();
  envHomeRingR = Math.max(2.8, Math.min(5.6, (idiomGeo.boundingSphere?.radius || 3.6) * 1.10));
}

// ✅ 初始/收拢更快“成型”
function nudgeParticlesTowardTargets(amount=0.70){
  const a = clamp(amount, 0, 1);
  for(let i=0;i<activeCount;i++){
    const px=aPos[i*3+0], py=aPos[i*3+1], pz=aPos[i*3+2];
    const tx=aTar[i*3+0], ty=aTar[i*3+1], tz=aTar[i*3+2];
    aPos[i*3+0] = lerp(px, tx, a);
    aPos[i*3+1] = lerp(py, ty, a);
    aPos[i*3+2] = lerp(pz, tz, a);
    aVel[i*3+0] *= 0.18;
    aVel[i*3+1] *= 0.18;
    aVel[i*3+2] *= 0.18;
  }
  idiomGeo.attributes.position.needsUpdate = true;
  idiomGeo.attributes.aVel.needsUpdate = true;
}

const idiomMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  depthTest: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uTime: { value: 0 },
    uMix: { value: 0 },
    uFocus: { value: 0 },
    uMap: { value: MA_TEX },
    uScatterFade: { value: 0.22 }
  },
  vertexShader: `
    uniform float uTime;
    uniform float uMix;
    uniform float uFocus;
    uniform float uScatterFade;
    attribute float aSeed;
    varying float vSeed;
    varying float vGlow;
    varying float vAlpha;
    void main(){
      vSeed = aSeed;

      vec3 p = position;

      float t = uTime*(0.7 + aSeed*1.3);
      p.x += cos(t + aSeed*12.0) * (0.02 + aSeed*0.05);
      p.y += sin(t*0.9 + aSeed*10.0) * (0.03 + aSeed*0.06);
      p.z += sin(t*1.1 + aSeed* 8.0) * (0.02 + aSeed*0.05);

      p *= (1.0 + uFocus*(0.06 + aSeed*0.12));

      vec4 mv = modelViewMatrix * vec4(p, 1.0);
      gl_Position = projectionMatrix * mv;

      float dist = max(0.001, -mv.z);

      float tw = 0.90 + 0.10*sin(uTime*2.2 + aSeed*9.0);
      float size = (uMix < 0.5) ? 1.05 : 0.90;
      gl_PointSize = clamp(size*tw*(120.0/dist), 0.7, 2.2);

      vGlow = 0.60 + 0.40*sin(uTime*2.0 + aSeed*11.0);
      vAlpha = mix(1.0, uScatterFade, uMix);
    }
  `,
  fragmentShader: `
    precision highp float;
    uniform sampler2D uMap;
    varying float vSeed;
    varying float vGlow;
    varying float vAlpha;
    void main(){
      vec4 m = texture2D(uMap, gl_PointCoord);
      if(m.a < 0.06) discard;

      vec3 gold = vec3(0.83,0.69,0.22);
      vec3 red  = vec3(0.70,0.07,0.15);
      vec3 warm = vec3(1.00,0.92,0.72);

      float k = smoothstep(0.20, 0.95, vSeed);
      vec3 col = mix(warm, gold, k);
      col = mix(col, red, smoothstep(0.78, 0.98, vSeed)*0.45);

      float a = m.a * (0.55 + 0.65*vGlow) * vAlpha;
      gl_FragColor = vec4(col * (1.10 + 0.55*m.a), a);
    }
  `
});

const idiomPoints = new THREE.Points(idiomGeo, idiomMat);
idiomPoints.frustumCulled = false;
idiomPoints.layers.enable(BLOOM_LAYER);
idiomGroup.add(idiomPoints);

// 初始成语：稳定、快速成型
rebuildIdiomTargets(selectedIdiom);
nudgeParticlesTowardTargets(0.78);

// ---------------------------
// 红包系统：围绕成语 3D 包裹 + 慢速布朗运动；降低旋转速度
// ---------------------------
const ENVELOPES = IS_MOBILE ? 160 : 240;
const envGroup = new THREE.Group();
idiomGroup.add(envGroup);

function makeRedEnvelopeTexture(){
  const c = document.createElement("canvas");
  c.width=256; c.height=320;
  const ctx = c.getContext("2d");

  const g = ctx.createLinearGradient(0,0,0,320);
  g.addColorStop(0, "#d01a35");
  g.addColorStop(1, "#7b081a");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,256,320);

  ctx.strokeStyle = "rgba(212,175,55,.85)";
  ctx.lineWidth = 10;
  ctx.strokeRect(14,14,228,292);

  ctx.save();
  ctx.translate(128,190);
  ctx.beginPath();
  ctx.fillStyle = "rgba(212,175,55,.92)";
  ctx.arc(0,0,42,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle = "rgba(90,60,10,.80)";
  ctx.font = "900 54px ui-sans-serif, system-ui, -apple-system";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText("福", 0, 2);
  ctx.restore();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}
// 员工头像纹理系统（替代红包）
const envGeo = new THREE.PlaneGeometry(0.14, 0.18, 1, 1);
const avatarTextures = [];
const avatarMaterials = [];
let avatarTexturesLoaded = false;

// 加载员工头像纹理
async function loadAvatarTextures(){
  if(avatarTexturesLoaded) return;
  
  avatarTexturesLoaded = true;
  const loader = new THREE.TextureLoader();
  
  // 优先从 blesses 配置加载头像
  if(Array.isArray(blesses) && blesses.length > 0){
    for(let i = 0; i < blesses.length; i++){
      const bless = blesses[i];
      if(bless.avatar){
        try{
          const tex = await new Promise((resolve, reject) => {
            loader.load(
              bless.avatar,
              resolve,
              undefined,
              reject
            );
          });
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.generateMipmaps = false;
          avatarTextures.push(tex);
          
          const mat = new THREE.MeshBasicMaterial({
            map: tex,
            transparent: true,
            opacity: 0.98,
            depthWrite: false,
            depthTest: false,
            toneMapped: false
          });
          avatarMaterials.push(mat);
        }catch(e){
          console.warn(`Failed to load avatar: ${bless.avatar}`, e);
        }
      }
    }
  }
  
  // 如果配置中没有头像或加载失败，直接从 employees 目录加载（1.png 到 4.png）
  if(avatarMaterials.length === 0){
    const employeeImages = ["1.png", "2.png", "3.png", "4.png"];
    for(let i = 0; i < employeeImages.length; i++){
      const imgPath = `assets/images/employees/${employeeImages[i]}`;
      try{
        const tex = await new Promise((resolve, reject) => {
          loader.load(
            imgPath,
            resolve,
            undefined,
            reject
          );
        });
        tex.colorSpace = THREE.SRGBColorSpace;
        tex.minFilter = THREE.LinearFilter;
        tex.magFilter = THREE.LinearFilter;
        tex.generateMipmaps = false;
        avatarTextures.push(tex);
        
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
          opacity: 0.98,
          depthWrite: false,
          depthTest: false,
          toneMapped: false
        });
        avatarMaterials.push(mat);
      }catch(e){
        console.warn(`Failed to load employee image: ${imgPath}`, e);
      }
    }
  }
  
  // 如果仍然没有加载到头像，使用默认红包纹理作为最后的后备
  if(avatarMaterials.length === 0){
    const ENV_TEX = makeRedEnvelopeTexture();
    const defaultMat = new THREE.MeshBasicMaterial({
      map: ENV_TEX,
      transparent: true,
      opacity: 0.98,
      depthWrite: false,
      depthTest: false,
      toneMapped: false
    });
    avatarMaterials.push(defaultMat);
  }
}

// 改为普通 Mesh 数组以支持不同头像
const envMeshes = [];

const envHomeLocal = new Array(ENVELOPES);
const envScatterWorld = new Array(ENVELOPES);
const envVelWorld = new Array(ENVELOPES);
const envScale = new Array(ENVELOPES);
const envSeed = new Array(ENVELOPES);
const envAvatarIndex = new Array(ENVELOPES); // 每个红包对应的头像索引

function sampleEnvelopeHomeLocal(){
  const u = Math.random();
  const v = Math.random();
  const theta = u * Math.PI * 2;
  const phi = Math.acos(2*v - 1);
  const r = envHomeRingR * (0.92 + Math.random()*0.38);

  const x = Math.sin(phi)*Math.cos(theta) * r;
  const y = Math.cos(phi) * r * 0.62;
  const z = Math.sin(phi)*Math.sin(theta) * r;

  return new THREE.Vector3(x, y, z);
}

function sampleScatterWorld(){
  const R = 7.3;
  const u = Math.random();
  const v = Math.random();
  const theta = u * Math.PI * 2;
  const phi = Math.acos(2 * v - 1);
  const rr = (0.45 + Math.pow(Math.random(), 0.65) * 0.55) * R;
  const x = rr * Math.sin(phi) * Math.cos(theta);
  const y = rr * Math.cos(phi) * 0.75 + 2.2;
  const z = rr * Math.sin(phi) * Math.sin(theta);
  return new THREE.Vector3(x,y,z);
}

// 初始化红包网格和头像索引
function initEnvelopeMeshes(){
  // 等待头像加载完成
  if(avatarMaterials.length === 0) return;
  
  // 清除旧的网格
  envMeshes.forEach(mesh => envGroup.remove(mesh));
  envMeshes.length = 0;
  
  for(let i=0;i<ENVELOPES;i++){
    envHomeLocal[i] = sampleEnvelopeHomeLocal();
    envScatterWorld[i] = sampleScatterWorld();
    envVelWorld[i] = new THREE.Vector3(0,0,0);
    
    envScale[i] = lerp(0.42, 1.18, Math.pow(Math.random(), 0.65));
    envSeed[i] = Math.random()*1000;
    
    // 随机分配头像索引
    envAvatarIndex[i] = Math.floor(Math.random() * avatarMaterials.length);
    
    // 创建网格
    const mat = avatarMaterials[envAvatarIndex[i]];
    const mesh = new THREE.Mesh(envGeo, mat);
    mesh.layers.enable(BLOOM_LAYER);
    envMeshes.push(mesh);
    envGroup.add(mesh);
  }
}

// 延迟初始化，等待头像加载
(async function(){
  await loadAvatarTextures();
  initEnvelopeMeshes();
})();

// 监听 blesses 加载完成，重新初始化
let checkBlessesInterval = setInterval(() => {
  if(blesses.length > 0 && !avatarTexturesLoaded){
    loadAvatarTextures().then(() => {
      initEnvelopeMeshes();
      clearInterval(checkBlessesInterval);
    });
  }
}, 500);
setTimeout(() => clearInterval(checkBlessesInterval), 10000);

const _obj = new THREE.Object3D();
const _tmp = new THREE.Vector3();
const _homeWorld = new THREE.Vector3();

function updateEnvelopes(time, dt){
  if(envMeshes.length !== ENVELOPES) return; // 等待初始化完成
  
  for(let i=0;i<ENVELOPES;i++){
    const seed = envSeed[i];
    const mesh = envMeshes[i];

    const bx = Math.sin(time*0.55 + seed) * 0.11 + Math.sin(time*0.17 + seed*1.7)*0.08;
    const by = Math.cos(time*0.48 + seed*1.3) * 0.10 + Math.sin(time*0.15 + seed*2.1)*0.06;
    const bz = Math.sin(time*0.52 + seed*0.8) * 0.11 + Math.cos(time*0.14 + seed*1.9)*0.08;

    _homeWorld.copy(envHomeLocal[i]);
    _homeWorld.x += bx;
    _homeWorld.y += by;
    _homeWorld.z += bz;

    const sW = envScatterWorld[i];
    const vW = envVelWorld[i];

    vW.multiplyScalar(Math.pow(0.92, dt*60.0));
    sW.addScaledVector(vW, dt);
    sW.y += Math.sin(time*0.9 + seed)*0.012;

    idiomGroup.updateMatrixWorld(true);
    _tmp.copy(_homeWorld).applyMatrix4(idiomGroup.matrixWorld);

    const x = lerp(_tmp.x, sW.x, mix);
    const y = lerp(_tmp.y, sW.y, mix);
    const z = lerp(_tmp.z, sW.z, mix);

    mesh.position.set(x,y,z);
    mesh.quaternion.copy(camera.quaternion);

    // 降低自旋
    const rot = (Math.sin(time*0.32 + seed)*0.06) + (Math.sin(time*0.18 + seed*0.9)*0.04);
    mesh.rotation.z = rot;

    const s = envScale[i] * (1.0 - focus*0.08);
    mesh.scale.setScalar(s);
  }
}

function kickScatterImpulse(){
  for(let i=0;i<ENVELOPES;i++){
    const p = envScatterWorld[i];
    const dir = new THREE.Vector3(p.x, p.y-2.25, p.z).normalize();
    dir.x += (Math.random()-0.5)*0.35;
    dir.y += (Math.random()-0.2)*0.25;
    dir.z += (Math.random()-0.5)*0.35;
    dir.normalize();
    const kick = 2.2 + Math.random()*4.0;
    envVelWorld[i].addScaledVector(dir, kick);
  }

  for(let i=0;i<activeCount;i++){
    const sx = (Math.random()-0.5);
    const sy = (Math.random()-0.2);
    const sz = (Math.random()-0.5);
    const len = Math.max(1e-4, Math.sqrt(sx*sx+sy*sy+sz*sz));
    const k = 1.1 + Math.random()*2.2;
    aVel[i*3+0] += (sx/len)*k;
    aVel[i*3+1] += (sy/len)*k;
    aVel[i*3+2] += (sz/len)*k;
  }
  idiomGeo.attributes.aVel.needsUpdate = true;
}

// ---------------------------
// 火花烟花（轻量）
// ---------------------------
class Fireworks {
  constructor(maxParticles=(IS_MOBILE?4200:6500)){
    this.max=maxParticles;
    this.pos=new Float32Array(this.max*3);
    this.vel=new Float32Array(this.max*3);
    this.col=new Float32Array(this.max*3);
    this.life=new Float32Array(this.max);
    this.age =new Float32Array(this.max);
    this.active=new Uint8Array(this.max);

    this.geo=new THREE.BufferGeometry();
    this.geo.setAttribute("position", new THREE.BufferAttribute(this.pos,3));
    this.geo.setAttribute("color", new THREE.BufferAttribute(this.col,3));

    this.mat=new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, depthTest:false,
      blending:THREE.AdditiveBlending,
      uniforms:{ uOpacity:{value:1.0}, uMap:{value:DOT_TEX} },
      vertexShader:`
        attribute vec3 color;
        uniform float uOpacity;
        varying vec3 vColor;
        varying float vO;
        void main(){
          vColor=color; vO=uOpacity;
          vec4 mv=modelViewMatrix*vec4(position,1.0);
          gl_Position=projectionMatrix*mv;
          float dist=max(0.001,-mv.z);
          gl_PointSize=clamp(1.15*(160.0/dist), 0.55, 3.2);
        }
      `,
      fragmentShader:`
        precision highp float;
        uniform sampler2D uMap;
        varying vec3 vColor;
        varying float vO;
        void main(){
          vec4 m=texture2D(uMap, gl_PointCoord);
          if(m.a<0.02) discard;
          gl_FragColor=vec4(vColor, m.a * vO);
        }
      `
    });

    this.points=new THREE.Points(this.geo,this.mat);
    this.points.frustumCulled=false;
    this.points.renderOrder = 20000;
    this.points.layers.enable(0);
    this.points.layers.enable(BLOOM_LAYER);
    scene.add(this.points);
    this.spawnTimer=0;
  }

  hsvToRgb(h,s,v){
    const i=Math.floor(h*6), f=h*6-i;
    const p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
    const m=i%6;
    const r=[v,q,p,p,t,v][m], g=[t,v,v,q,p,p][m], b=[p,p,t,v,v,q][m];
    return [r,g,b];
  }

  spawnBurst(origin, count){
    for(let n=0;n<count;n++){
      let idx=-1;
      for(let i=0;i<this.max;i++){ if(this.active[i]===0){ idx=i; break; } }
      if(idx<0) break;

      this.active[idx]=1;
      this.age[idx]=0;
      this.life[idx]=1.1+Math.random()*1.0;

      const [r,g,b]=this.hsvToRgb(Math.random(), 0.70+Math.random()*0.28, 0.82+Math.random()*0.18);
      this.col[idx*3]=r; this.col[idx*3+1]=g; this.col[idx*3+2]=b;

      this.pos[idx*3]=origin.x+(Math.random()-0.5)*0.22;
      this.pos[idx*3+1]=origin.y+(Math.random()-0.5)*0.22;
      this.pos[idx*3+2]=origin.z+(Math.random()-0.5)*0.22;

      const u=Math.random(), v2=Math.random();
      const theta=u*Math.PI*2, phi=Math.acos(2*v2-1);
      const sp=2.9+Math.random()*4.8;
      this.vel[idx*3]=Math.sin(phi)*Math.cos(theta)*sp;
      this.vel[idx*3+1]=Math.cos(phi)*sp*0.70+1.0;
      this.vel[idx*3+2]=Math.sin(phi)*Math.sin(theta)*sp;
    }
  }

  update(dt, opacity){
    this.mat.uniforms.uOpacity.value = opacity;
    this.points.visible = opacity > 0.02;
    if(!this.points.visible) return;

    this.spawnTimer -= dt;
    if(this.spawnTimer<=0){
      this.spawnTimer = 1.05 + Math.random()*1.25;
      const ox=(Math.random()-0.5)*18;
      const oy=5.2 + Math.random()*7.0;
      const oz=-14 - Math.random()*22;
      this.spawnBurst(new THREE.Vector3(ox,oy,oz), IS_MOBILE ? 95 : 150);
    }

    for(let i=0;i<this.max;i++){
      if(this.active[i]===0) continue;
      this.age[i]+=dt;
      const t=this.age[i]/this.life[i];
      if(t>=1){
        this.active[i]=0;
        this.pos[i*3]=9999; this.pos[i*3+1]=9999; this.pos[i*3+2]=9999;
        continue;
      }

      this.vel[i*3+1] -= 3.0*dt;
      const drag=Math.pow(0.983, dt*60);
      this.vel[i*3]*=drag; this.vel[i*3+1]*=drag; this.vel[i*3+2]*=drag;

      this.pos[i*3]+=this.vel[i*3]*dt;
      this.pos[i*3+1]+=this.vel[i*3+1]*dt;
      this.pos[i*3+2]+=this.vel[i*3+2]*dt;
    }
    this.geo.attributes.position.needsUpdate = true;
    this.geo.attributes.color.needsUpdate = true;
  }
}
const fireworks = new Fireworks();

// ---------------------------
// 红包开封流程（只由三指捏合触发）
// ---------------------------
function pickVideo(){ return HORSE_VIDEOS[Math.floor(Math.random()*HORSE_VIDEOS.length)]; }

async function triggerRedPacketFlow(){
  if(mode !== Mode.FOCUS) setMode(Mode.FOCUS);

  // 如果存在员工祝福配置，则从 blesses 中随机选择一位未抽中的员工
  let chosenBless = null;
  if(Array.isArray(blesses) && blesses.length > 0){
    // 筛选出未被抽中的员工
    const availableBlesses = blesses.filter(b => {
      const id = b.id || b.name;
      return id && !drawnEmployeeIds.has(id);
    });
    
    // 如果所有员工都被抽中，重置记录并重新开始
    if(availableBlesses.length === 0){
      drawnEmployeeIds.clear();
      availableBlesses.push(...blesses);
    }
    
    // 从未抽中的员工中随机选择
    if(availableBlesses.length > 0){
      chosenBless = availableBlesses[Math.floor(Math.random()*availableBlesses.length)];
      
      // 记录已抽中的员工ID
      const employeeId = chosenBless.id || chosenBless.name;
      if(employeeId){
        drawnEmployeeIds.add(employeeId);
      }
    }
  }

  if(chosenBless){
    const name = chosenBless.name || "未知员工";
    const blessing = chosenBless.blessing || "";
    const avatar = chosenBless.avatar || "";

    // 福：红包换成员工头像，中间字改为"福"，右侧展示员工姓名 + 祝语（不显示右侧头像）
    focusTitleEl.textContent = name;
    focusTextEl.textContent = blessing;
    // 福模式下隐藏右侧头像小圆框
    if(focusAvatarEl){
      focusAvatarEl.style.display = "none";
    }
    // 确保使用员工头像作为"福"的背景
    // 优先使用配置中的头像路径
    let avatarToUse = avatar;
    
    // 如果配置中没有头像，从 employees 目录随机选择一张
    if(!avatarToUse || avatarToUse === ""){
      const employeeImages = ["1.png", "2.png", "3.png", "4.png"];
      const randomImg = employeeImages[Math.floor(Math.random() * employeeImages.length)];
      avatarToUse = `assets/images/employees/${randomImg}`;
    }
    
    // 确保头像路径正确（如果路径不完整，补充完整路径）
    if(avatarToUse && !avatarToUse.startsWith("assets/") && !avatarToUse.startsWith("http")){
      avatarToUse = `assets/images/employees/${avatarToUse}`;
    }
    
    // 设置红包背景为员工头像
    if(avatarToUse){
      setPacketAvatarMode(avatarToUse, "福");
    }else{
      // 最后的后备方案
      setPacketDefault("福");
    }
    if(rewardVideoWrap) rewardVideoWrap.style.display = "none";
  }

  packetEl.classList.remove("open");
  void packetEl.offsetWidth;
  packetEl.classList.add("open");

  const url = pickVideo();
  try{
    horseVideo.pause();
    horseVideo.src = url;
    horseVideo.load();
    await horseVideo.play().catch(()=>{});
  }catch(e){}
}

// ---------------------------
// 手势识别（握拳=凝聚；张开=散开；三指捏合=抓红包）
// ---------------------------
let hands = null;
let handEnabled = false;
let lastLandmarks = null;
let lastLandmarksTs = 0;

function dist2(a,b){
  const dx=a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0);
  return Math.sqrt(dx*dx+dy*dy+dz*dz);
}
function computeGesture(lm){
  const wrist=lm[0];
  const handSize=Math.max(1e-6, dist2(wrist, lm[9]));

  function extended(tip,pip){
    const dt=dist2(lm[tip], wrist);
    const dp=dist2(lm[pip], wrist);
    return dt > dp*1.12;
  }

  const thumbExt = extended(4,2);
  const indexExt = extended(8,6);
  const middleExt= extended(12,10);
  const ringExt  = extended(16,14);
  const pinkyExt = extended(20,18);

  const extCount = [thumbExt,indexExt,middleExt,ringExt,pinkyExt].filter(Boolean).length;

  const openHand = (extCount >= 4);
  const closeHand = (extCount <= 1);

  const dTI = dist2(lm[4], lm[8]) / handSize;
  const dTM = dist2(lm[4], lm[12]) / handSize;
  const dIM = dist2(lm[8], lm[12]) / handSize;
  const pinch3 = (dTI < 0.33 && dTM < 0.35 && dIM < 0.34);

  return { openHand, closeHand, pinch3 };
}

let prevPinch=false;
let pinchCooldown=0;

// ✅ 关键：凝聚只触发一次（需要握拳保持一小段时间），避免“闪现其他成语”
function handleGestureStable(g, dt){
  mergeCooldownSec = Math.max(0, mergeCooldownSec - dt);
  
  // 第一次检测到手势动作时，从 "HAPPY NEW YEAR" 切换到成语
  if(!hasSwitchedToIdioms && (g.openHand || g.closeHand || g.pinch3)){
    hasSwitchedToIdioms = true;
    selectedIdiom = IDIOMS[Math.floor(Math.random()*IDIOMS.length)];
    rebuildIdiomTargets(selectedIdiom);
    nudgeParticlesTowardTargets(0.78);
  }

  if(g.openHand){
    openHoldSec += dt;
    closeHoldSec = 0;

    // 张开保持>0.10s才认为进入散开 cycle（防误触）
    if(openHoldSec > 0.10){
      cycleLocked = false;      // 允许下一次握拳选新成语
      setMode(Mode.SCATTER);
    }
  }else{
    openHoldSec = 0;
  }

  if(g.closeHand){
    closeHoldSec += dt;
  }else{
    closeHoldSec = 0;
  }

  // 三指捏合：抓红包（独立于散/聚）
  pinchCooldown = Math.max(0, pinchCooldown - dt);
  const pinchEdge = g.pinch3 && !prevPinch;
  prevPinch = g.pinch3;
  if(pinchEdge && pinchCooldown<=0){
    triggerRedPacketFlow();
    pinchCooldown = 0.60;
  }

  // 握拳凝聚：要求 “从散开进入” + “握拳保持” + “冷却结束”
  const canMerge = (!cycleLocked) && (mode === Mode.SCATTER || mix > 0.55) && mergeCooldownSec <= 0;
  if(canMerge && closeHoldSec > 0.14){
    cycleLocked = true;
    mergeCooldownSec = 0.55;

    // ✅ 只选一次成语，并立刻构建目标；后续不再变动，直到再次张开
    selectedIdiom = IDIOMS[Math.floor(Math.random()*IDIOMS.length)];
    rebuildIdiomTargets(selectedIdiom);

    // ✅ 立刻成型更清晰
    nudgeParticlesTowardTargets(0.76);

    // 凝聚阶段加速一段时间（避免“还不成型”）
    mergeBoost = 1.0;

    // 刷新红包 home（保持环绕）
    for(let i=0;i<ENVELOPES;i++){
      envHomeLocal[i] = sampleEnvelopeHomeLocal();
    }

    setMode(Mode.MERGE);
  }
}

async function startHands(){
  if(!window.Hands){
    statusText.textContent="手势组件未加载（网络问题？）";
    return;
  }
  if(!navigator.mediaDevices?.getUserMedia){
    statusText.textContent="当前浏览器不支持摄像头 API";
    return;
  }

  hands = new window.Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
  });
  hands.onResults((results)=>{
    const lm = results.multiHandLandmarks?.[0] || null;
    if(lm){
      lastLandmarks = lm;
      lastLandmarksTs = performance.now();
    }
  });

  const stream = await navigator.mediaDevices.getUserMedia({
    audio:false,
    video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} }
  });

  videoEl.srcObject=stream;
  await videoEl.play();

  handEnabled=true;
  led.classList.add("on");
  statusText.textContent="手势已启用：握拳凝聚 / 张开散开 / 三指捏合抓红包";

  let busy=false, lastSent=0;
  async function pump(){
    if(!handEnabled) return;
    const now=performance.now();
    if(!busy && (now-lastSent)>33){
      busy=true; lastSent=now;
      try{ await hands.send({ image: videoEl }); }catch(e){}
      busy=false;
    }
    requestAnimationFrame(pump);
  }
  pump();
}

btnStart.addEventListener("click", async ()=>{
  try{
    btnStart.disabled=true;
    btnStart.textContent="启用中…";
    await warmupVideo(horseRunVideo);
    await startHands();
    tryStartBgm();
    btnStart.textContent="手势识别已开启";
  }catch(e){
    statusText.textContent="启用失败：请允许摄像头权限，并确保 HTTPS";
    btnStart.disabled=false;
    btnStart.textContent="启用手势识别";
  }
});

btnReset.addEventListener("click", ()=>{
  // 重置时：如果已经切换到成语，则继续使用成语；否则使用初始的 "HAPPY NEW YEAR"
  if(hasSwitchedToIdioms){
    selectedIdiom = IDIOMS[Math.floor(Math.random()*IDIOMS.length)];
  }else{
    selectedIdiom = "HAPPY NEW YEAR";
  }
  rebuildIdiomTargets(selectedIdiom);
  nudgeParticlesTowardTargets(0.78);
  
  // 重置已抽中记录，允许重新抽奖
  drawnEmployeeIds.clear();

  // 重新分配头像和位置
  if(envMeshes.length === ENVELOPES){
    for(let i=0;i<ENVELOPES;i++){
      envHomeLocal[i]=sampleEnvelopeHomeLocal();
      envScatterWorld[i]=sampleScatterWorld();
      envVelWorld[i].set(0,0,0);
      // 重新随机分配头像
      if(avatarMaterials.length > 0){
        envAvatarIndex[i] = Math.floor(Math.random() * avatarMaterials.length);
        envMeshes[i].material = avatarMaterials[envAvatarIndex[i]];
      }
    }
  }else{
    // 如果网格未初始化，则初始化
    initEnvelopeMeshes();
  }
  hideFocusOverlay();
  cycleLocked = true;
  openHoldSec = 0;
  closeHoldSec = 0;
  mergeCooldownSec = 0;
  mergeBoost = 0;

  setMode(Mode.MERGE);
  statusText.textContent="已重置：凝聚态（稳定成语 + 红包环绕）";
});

// ---------------------------
// 相机
// ---------------------------
let yaw=0.0, pitch=0.14, radius=10.4;
let yawT=yaw, pitchT=pitch;

let dragging=false, lastX=0, lastY=0;
canvas.addEventListener("pointerdown",(e)=>{
  dragging=true; lastX=e.clientX; lastY=e.clientY;
});
window.addEventListener("pointerup",()=>dragging=false);
window.addEventListener("pointermove",(e)=>{
  if(!dragging) return;
  if(mode !== Mode.SCATTER) return;
  const dx=e.clientX-lastX;
  const dy=e.clientY-lastY;
  lastX=e.clientX; lastY=e.clientY;
  yawT += dx*0.0042;
  pitchT += dy*0.0032;
});

// ---------------------------
// 散开态湍流场：中心空腔 + “整体向左流动”
// 说明：你要“湍流在视频下方（层级）+ 向左流动（-X）”，这里实现的是速度场偏置到左侧。
// ---------------------------
function turbulenceAccel(px, py, pz, seed, time, scatter01){
  const rx = px;
  const rz = pz;
  const r  = Math.sqrt(rx*rx + rz*rz) + 1e-4;

  const holeR = 1.55;
  let ax = 0, ay = 0, az = 0;

  // 中央空腔（给马视频让位）
  if(r < holeR){
    const rep = (holeR - r) * 10.0;
    ax += (rx / r) * rep;
    az += (rz / r) * rep;
  }

  // 环状拉回
  const ringR = 3.15;
  const radial = (ringR - r) * 1.35;
  ax += (rx / r) * radial;
  az += (rz / r) * radial;

  // 旋涡（增强立体感）
  const dir = (seed < 0.5) ? 1.0 : -1.0;
  const swirl = (2.1 + 1.0*Math.sin(time*0.7 + seed*7.0)) * dir;
  ax += (-rz / r) * swirl;
  az += ( rx / r) * swirl;

  // 垂向扰动
  ay += Math.sin(time*2.0 + seed*13.0 + px*0.7) * 1.05;
  ay += Math.cos(time*1.6 + seed*9.0  + pz*0.6) * 0.78;

  // ✅ 整体向左（-X）流动：与 scatter 强度挂钩
  // 这样马从左向右跑时，粒子“逆风”形成更强的动感和层次
  ax += (-2.15) * scatter01;

  // 加一点“尾流”拉伸感（越靠外越明显）
  ax += (-0.75) * scatter01 * clamp(r/6.0, 0, 1);

  return { ax, ay, az };
}

// ---------------------------
// 成语粒子更新（凝聚更快且稳定，不再闪现换词）
// ---------------------------
function updateIdiom(dt, time){
  // 凝聚态绕Y轴旋转更快
  if(mode === Mode.MERGE && focus < 0.1){
    idiomGroup.rotation.y += dt * 0.70;
  }else{
    idiomGroup.rotation.y += dt * 0.12;
  }

  // mix 过渡更快：散->聚明显更“丝滑”
  //（mix 的实际更新在 animate 里）
  const pull = (1.0 - mix);

  // ✅ 凝聚阶段短时 boost（避免“还不成型”）
  const boost = mergeBoost;
  const spring = 11.8 + boost*12.0;     // 凝聚更强
  const drag   = 4.4  + boost*2.0;      // 稳定更快
  mergeBoost = Math.max(0, mergeBoost - dt*2.2);

  const scatter01 = clamp((mix - 0.10)/0.90, 0, 1);

  for(let i=0;i<activeCount;i++){
    const px=aPos[i*3+0], py=aPos[i*3+1], pz=aPos[i*3+2];
    let vx=aVel[i*3+0], vy=aVel[i*3+1], vz=aVel[i*3+2];

    const tx=aTar[i*3+0], ty=aTar[i*3+1], tz=aTar[i*3+2];

    let ax = (tx - px) * spring * pull;
    let ay = (ty - py) * spring * pull;
    let az = (tz - pz) * spring * pull;

    // 散开态：湍流（并整体向左流动）
    if(scatter01 > 0){
      const seed = aSeed[i];
      const t = turbulenceAccel(px, py, pz, seed, time, scatter01);
      ax += t.ax;
      ay += t.ay;
      az += t.az;

      // 微噪声细化星屑感
      ax += Math.sin(time*3.0 + seed*17.0) * 0.32 * scatter01;
      az += Math.cos(time*2.6 + seed*19.0) * 0.32 * scatter01;
    }

    vx += ax*dt; vy += ay*dt; vz += az*dt;

    vx *= Math.exp(-drag*dt);
    vy *= Math.exp(-drag*dt);
    vz *= Math.exp(-drag*dt);

    const keep = 0.56 + 0.44*mix;
    vx *= keep; vy *= keep; vz *= keep;

    aPos[i*3+0] = px + vx*dt;
    aPos[i*3+1] = py + vy*dt;
    aPos[i*3+2] = pz + vz*dt;

    aVel[i*3+0]=vx; aVel[i*3+1]=vy; aVel[i*3+2]=vz;
  }

  idiomGeo.attributes.position.needsUpdate = true;
  idiomMat.uniforms.uTime.value = time;
  idiomMat.uniforms.uMix.value = mix;
  idiomMat.uniforms.uFocus.value = focus;
}

function applyCamera(dt, time){
  if(mode===Mode.MERGE){
    yawT += dt*0.12;
    pitchT = damp(pitchT, 0.14, 2.8, dt);
  }else if(mode===Mode.FOCUS){
    pitchT = damp(pitchT, 0.12, 3.0, dt);
  }else{
    pitchT = clamp(pitchT, -0.22, 0.62);
  }

  yaw = damp(yaw, yawT, 6.0, dt);
  pitch = damp(pitch, pitchT, 6.0, dt);

  const r=radius;
  const cx = Math.sin(yaw)*Math.cos(pitch)*r;
  const cy = 2.25 + Math.sin(pitch)*r*0.33;
  const cz = Math.cos(yaw)*Math.cos(pitch)*r;
  camera.position.set(cx,cy,cz);
  camera.lookAt(0,2.25,0);

  goldPoint.position.set(
    Math.sin(yaw*0.7)*2.0,
    5.0 + Math.sin(time*0.7)*0.12,
    3.0 + Math.cos(yaw*0.7)*1.2
  );
}

// ---------------------------
// 动画循环
// ---------------------------
let time=0;
let lastTime=performance.now();

function animate(){
  const now=performance.now();
  const dt=clamp((now-lastTime)/1000, 0, 0.035);
  lastTime=now;
  time += dt;

  // 手势（稳定去抖 + 单次触发凝聚）
  if(handEnabled && lastLandmarks && (now-lastLandmarksTs) < 180){
    const g = computeGesture(lastLandmarks);
    handleGestureStable(g, dt);
  }

  // ✅ 更快更丝滑的散->聚过渡（你要的“不要立马切换”）
  mix = damp(mix, targetMix, 4.6, dt);

  targetFocus = (mode===Mode.FOCUS) ? 1 : 0;
  focus = damp(focus, targetFocus, 4.0, dt);

  const scatter01 = clamp((mix - 0.10)/0.90, 0, 1);
  galaxy.update(time, scatter01);

  // 视频显示
  if(mode===Mode.SCATTER){
    if(horseReady || horseRunVideo.readyState>=2) horseGroup.visible = true;
  }else{
    horseGroup.visible = false;
  }
  updateHorseBillboard();

  // ✅ 渲染层级：散开态“湍流在视频下方”
  // 规则：散开态 -> 粒子 renderOrder < 视频 renderOrder；凝聚态 -> 粒子最高
  if(scatter01 > 0.55){
    idiomPoints.renderOrder = 18000;      // 湍流在下
    envMeshes.forEach(m => m.renderOrder = 19000);          // 头像也在下（散开时不抢镜）
    horsePlane.renderOrder = 30000;       // 马视频在上
  }else{
    idiomPoints.renderOrder = 60000;      // 凝聚时成语在最上
    envMeshes.forEach(m => m.renderOrder = 65000);          // 头像包裹
    horsePlane.renderOrder = 30000;
  }

  const fwOpacity = lerp(1.0, 0.35, scatter01);
  fireworks.update(dt, fwOpacity);

  applyCamera(dt, time);
  updateIdiom(dt, time);
  updateEnvelopes(time, dt);

  bloomPass.strength = damp(bloomPass.strength, lerp(1.08, 0.92, scatter01), 2.8, dt);
  bloomPass.radius   = damp(bloomPass.radius,   0.62, 2.8, dt);
  bloomPass.threshold= damp(bloomPass.threshold,0.16, 2.8, dt);

  camera.layers.set(BLOOM_LAYER);
  bloomComposer.render();
  camera.layers.set(0);
  finalComposer.render();

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// ---------------------------
// Resize
// ---------------------------
function onResize(){
  const w=window.innerWidth, h=window.innerHeight;
  const pr = Math.min(DPR_CAP, window.devicePixelRatio || 1);
  renderer.setPixelRatio(pr);
  renderer.setSize(w,h,false);

  camera.aspect=w/h; camera.updateProjectionMatrix();

  const bw = Math.max(2, Math.floor(w * BLOOM_SCALE));
  const bh = Math.max(2, Math.floor(h * BLOOM_SCALE));
  bloomComposer.setSize(bw,bh);
  bloomPass.setSize?.(bw,bh);

  finalComposer.setSize(w,h);
}
window.addEventListener("resize", onResize);
onResize();

// ---------------------------
// 初始化
// ---------------------------
statusText.textContent = "已加载：凝聚态（稳定成语 + 红包环绕）";
  // 重新初始化头像网格
  initEnvelopeMeshes();

horseVideo.muted = true;
horseVideo.loop = true;
horseVideo.playsInline = true;

</script>
</body>
</html>
