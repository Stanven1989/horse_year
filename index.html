<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>é©¬å¹´ç¥ç¦ Â· æ‰‹åŠ¿ç²’å­æˆè¯­ Â· çº¢åŒ…å¼€å° Â· çƒŸèŠ±èƒŒæ™¯</title>

  <!-- ES Module Shims (Import Maps) -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/build/three.module.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/EffectComposer.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/RenderPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/UnrealBloomPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/OutputPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/ShaderPass.js">

  <script type="importmap-shim">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --gold:#d4af37;
      --red:#b11226;
      --panel: rgba(10,10,12,.58);
      --panel2: rgba(4,6,9,.42);
      --line: rgba(212,175,55,.35);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
    }

    html,body{
      height:100%;
      margin:0;
      background: radial-gradient(120% 120% at 50% 30%, #14060a 0%, #070607 55%, #040405 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }

    #app{ position:fixed; inset:0; }
    canvas#gl{ position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; }

    .cinema-vignette{
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(120% 120% at 50% 45%, rgba(0,0,0,0) 42%, rgba(0,0,0,.62) 100%),
        radial-gradient(90% 70% at 50% 0%, rgba(212,175,55,.14) 0%, rgba(0,0,0,0) 60%),
        linear-gradient(180deg, rgba(177,18,38,.12) 0%, rgba(0,0,0,0) 40%);
      mix-blend-mode:screen;
      opacity:.95;
    }
    .film-grain{
      position:absolute; inset:-20%;
      pointer-events:none;
      background-image:
        repeating-linear-gradient(0deg, rgba(255,255,255,.025) 0 1px, rgba(0,0,0,0) 1px 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.018) 0 1px, rgba(0,0,0,0) 1px 4px);
      opacity:.22;
      transform:rotate(2deg);
      animation: grain 7s linear infinite;
      mix-blend-mode:overlay;
      filter: blur(.2px);
    }
    @keyframes grain{
      0%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
      50%{ transform:translate3d(2%, 1%, 0) rotate(2deg); }
      100%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
    }

    .hud{
      position:absolute; left:12px; right:12px; top:12px;
      display:flex; gap:10px; align-items:flex-start;
      pointer-events:none;
    }
    .panel{
      pointer-events:auto;
      flex:1 1 auto;
      max-width:920px;
      padding:12px 12px 10px;
      border:1px solid var(--line);
      border-radius:14px;
      background:linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      box-shadow: 0 14px 40px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
    }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }

    .brand{ display:flex; gap:10px; align-items:center; min-width:300px; }
    .badge{
      width:12px; height:12px; border-radius:999px;
      background: var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.18), 0 0 18px rgba(212,175,55,.45);
    }
    .title{ font-weight:800; letter-spacing:.3px; font-size:14px; line-height:1.2; }
    .subtitle{ font-size:12px; color:var(--muted); margin-top:2px; }

    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-left:auto; }

    button{
      pointer-events:auto;
      appearance:none;
      border:1px solid rgba(212,175,55,.38);
      color:var(--text);
      background:linear-gradient(180deg, rgba(177,18,38,.35), rgba(0,0,0,.22));
      border-radius:12px;
      padding:10px 12px;
      font-size:12px;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
      user-select:none;
    }
    button.secondary{
      border-color: rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.18));
      color: rgba(255,255,255,.86);
    }

    .tips{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(212,175,55,.22);
      display:flex; gap:10px; flex-wrap:wrap;
      font-size:12px; color:rgba(255,255,255,.78);
    }
    .chip{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius:999px;
      padding:6px 10px;
      display:inline-flex; gap:8px; align-items:center;
    }
    .chip b{ color:rgba(255,255,255,.92); font-weight:900; }

    .status{
      margin-left:auto;
      font-size:12px;
      color:rgba(255,255,255,.70);
      display:flex; align-items:center; gap:8px;
    }
    .led{
      width:8px; height:8px; border-radius:999px;
      background: rgba(255,255,255,.18);
      box-shadow:0 0 0 2px rgba(255,255,255,.06);
    }
    .led.on{
      background: var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.16), 0 0 16px rgba(212,175,55,.55);
    }

    .focusOverlay{
      position:absolute; inset:0;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding:16px 12px 22px;
      pointer-events:none;
      opacity:0;
      transform: translate3d(0, 10px, 0);
      transition: opacity .25s ease, transform .25s ease;
    }
    .focusOverlay.show{
      opacity:1;
      transform: translate3d(0,0,0);
    }
    .focusCard{
      pointer-events:auto;
      width:min(860px, calc(100vw - 24px));
      border-radius:18px;
      border:1px solid rgba(212,175,55,.45);
      background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(8,10,12,.66));
      box-shadow: 0 22px 70px rgba(0,0,0,.62);
      backdrop-filter: blur(12px);
      padding:14px 14px 12px;
      position:relative;
      overflow:hidden;
    }
    .focusCard:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(80% 120% at 25% 0%, rgba(212,175,55,.18), rgba(0,0,0,0) 60%),
        radial-gradient(80% 120% at 75% 0%, rgba(177,18,38,.16), rgba(0,0,0,0) 60%);
      pointer-events:none;
    }
    .focusTop{
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
      position:relative;
    }
    .packet{
      width:150px;
      height:190px;
      border-radius:16px;
      background: linear-gradient(180deg, rgba(177,18,38,.98), rgba(120,8,22,.98));
      border:1px solid rgba(212,175,55,.55);
      box-shadow: 0 18px 55px rgba(0,0,0,.6);
      position:relative;
      overflow:hidden;
      transform-origin: 50% 0%;
    }
    .packet:before{
      content:"";
      position:absolute; inset:-20%;
      background:
        radial-gradient(45% 70% at 30% 20%, rgba(212,175,55,.22), rgba(0,0,0,0) 60%),
        radial-gradient(45% 70% at 80% 70%, rgba(212,175,55,.15), rgba(0,0,0,0) 60%);
      pointer-events:none;
    }
    .packet .seal{
      position:absolute;
      left:50%; top:54%;
      width:62px; height:62px;
      transform:translate(-50%,-50%);
      border-radius:999px;
      background: radial-gradient(circle at 30% 30%, rgba(255,245,220,.95), rgba(212,175,55,.92) 60%, rgba(90,60,10,.85) 100%);
      box-shadow: 0 0 0 2px rgba(212,175,55,.20), 0 0 26px rgba(212,175,55,.45);
    }
    .packet .lid{
      position:absolute;
      left:0; top:0;
      width:100%; height:52%;
      background: linear-gradient(180deg, rgba(215,30,55,.98), rgba(140,10,30,.98));
      border-bottom:1px solid rgba(212,175,55,.35);
      transform-origin: 50% 100%;
      transform: rotateX(0deg);
    }
    .packet.open .lid{
      animation: openLid .55s ease forwards;
    }
    @keyframes openLid{
      0%{ transform: rotateX(0deg); }
      100%{ transform: rotateX(-125deg); }
    }

    .focusTextWrap{
      flex:1 1 320px;
      min-width: 260px;
    }
    .focusTitle{
      margin:0;
      font-size:15px;
      letter-spacing:.5px;
      position:relative;
      font-weight:900;
    }
    .focusLine{
      margin:8px 0 0;
      font-size:14px;
      line-height:1.6;
      color: rgba(255,255,255,.88);
      position:relative;
      white-space:pre-wrap;
      text-shadow: 0 0 18px rgba(212,175,55,.12);
    }

    .videoWrap{
      margin-top:12px;
      border-radius:16px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      position:relative;
      box-shadow: 0 16px 46px rgba(0,0,0,.55);
    }
    .videoWrap video{
      width:100%;
      height:auto;
      display:block;
      background:#000;
    }

    .small{
      margin-top:10px;
      font-size:12px;
      color: rgba(255,255,255,.65);
      position:relative;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }
    .kbd{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius:10px;
      padding:6px 10px;
    }

    video#cam{
      position:absolute;
      right:12px; bottom:12px;
      width:120px; height:160px;
      opacity:0;
      pointer-events:none;
      transform: translateZ(0);
    }

    @media (max-width:420px){
      .brand{ min-width: 240px; }
      .panel{ padding:10px; }
      button{ padding:9px 10px; }
      .tips{ gap:8px; }
      .packet{ width:130px; height:168px; }
    }
  </style>
</head>

<body>
<div id="app">
  <canvas id="gl"></canvas>
  <div class="cinema-vignette"></div>
  <div class="film-grain"></div>

  <div class="hud">
    <div class="panel">
      <div class="row">
        <div class="brand">
          <span class="badge"></span>
          <div>
            <div class="title">é©¬å¹´ç¥ç¦ Â· æ‰‹åŠ¿ç²’å­æˆè¯­ Â· çº¢åŒ…å¼€å° Â· çƒŸèŠ±èƒŒæ™¯</div>
            <div class="subtitle">Three.js / WebGL Â· MediaPipe Hands Â· è¾‰å…‰åæœŸ</div>
          </div>
        </div>

        <div class="controls">
          <button id="btnStart">å¯ç”¨æ‰‹åŠ¿è¯†åˆ«</button>
          <button id="btnReset" class="secondary">é‡ç½®</button>
          <button id="btnHelp" class="secondary">ç©æ³•æç¤º</button>
        </div>

        <div class="status">
          <span id="led" class="led"></span>
          <span id="statusText">é»˜è®¤ï¼šåˆæ‹¢æ€ï¼ˆå¯ç‚¹å‡»â€œå¯ç”¨æ‰‹åŠ¿è¯†åˆ«â€ï¼‰</span>
        </div>
      </div>

      <div class="tips" id="tips" style="display:none;">
        <span class="chip"><b>äº”æŒ‡æ¡æ‹³</b> â†’ æ”¶æ‹¢å‡èšï¼ˆå¹³æ»‘è¿‡æ¸¡ï¼‰</span>
        <span class="chip"><b>å¼ å¼€äº”æŒ‡</b> â†’ æ•£å¼€æ€ï¼ˆé©¬å½¢ç²’å­ + é“¶æ²³ç¯ç»•ï¼‰</span>
        <span class="chip"><b>ä¸‰æŒ‡æåˆ</b>ï¼ˆæ‹‡æŒ‡+é£ŸæŒ‡+ä¸­æŒ‡ï¼‰ â†’ æŠ“çº¢åŒ… â†’ å¼€å° â†’ æ’­æ”¾è§†é¢‘</span>
        <span class="chip"><b>æ•£å¼€æ€ç§»åŠ¨æ‰‹æŒ</b> â†’ æ—‹è½¬è§†è§’</span>
        <span class="chip"><b>åŒå‡»ç”»é¢</b> â†’ è§¦å‘å¼€å°ï¼ˆæ— æ‰‹åŠ¿å¤‡é€‰ï¼‰</span>
      </div>
    </div>
  </div>

  <div id="focusOverlay" class="focusOverlay">
    <div class="focusCard">
      <div class="focusTop">
        <div id="packet" class="packet">
          <div class="lid"></div>
          <div class="seal"></div>
        </div>
        <div class="focusTextWrap">
          <h3 id="focusTitle" class="focusTitle">æ­å–œå‘è´¢</h3>
          <div id="focusText" class="focusLine"></div>
        </div>
      </div>

      <div class="videoWrap">
        <video id="horseVideo" playsinline muted loop></video>
      </div>

      <div class="small">
        <span class="kbd">äº”æŒ‡æ¡æ‹³ï¼šå‡èšæˆè¯­</span>
        <span class="kbd">å¼ å¼€ï¼šé©¬å½¢+é“¶æ²³</span>
        <span class="kbd">ä¸‰æŒ‡æåˆï¼šæŠ“çº¢åŒ…</span>
      </div>
    </div>
  </div>

  <video id="cam" playsinline></video>
</div>

<script type="module-shim">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

const IDIOMS = [
  "é©¬åˆ°æˆåŠŸ","é¾™é©¬ç²¾ç¥","ä¸€é©¬å½“å…ˆ","ä¸‡é©¬å¥”è…¾","é©¬ä¸Šå‘è´¢","é©¬ä¸Šå¦‚æ„",
  "ç­–é©¬æ‰¬é­","å¿«é©¬åŠ é­","ä¸€é©¬å¹³å·","å¤©é©¬è¡Œç©º","é©¬åˆ°åŠŸæˆ","é©¬è·ƒé’±ç¨‹",
  "äººå¼ºé©¬å£®","é‡‘æˆˆé“é©¬","éªé©¬å¥”è…¾","é©¬è¹„ç”Ÿé£",
  "é©¬å¹´å¤§å‰","é©¬å¹´è¡Œå¤§è¿","é©¬å¹´ç¥¥ç‘","é‡‘é©¬è¿æ˜¥","å®é©¬é¦™è½¦",
  "é©¬åˆ°è´¢æ¥","é©¬åˆ°ç¦æ¥","é©¬åˆ°è¿æ¥"
];

const HORSE_VIDEOS = [
  "assets/videos/horse1.mp4",
  "assets/videos/horse2.mp4",
  "assets/videos/horse3.mp4",
  "assets/videos/horse4.mp4"
];

const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const DPR_CAP = IS_MOBILE ? 1.25 : 2.0;

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp  = (a,b,t)=>a+(b-a)*t;
const damp = (current, target, lambda, dt) => {
  const t = 1 - Math.exp(-lambda * dt);
  return current + (target - current) * t;
};

const canvas = document.getElementById("gl");
const statusText = document.getElementById("statusText");
const led = document.getElementById("led");
const btnStart = document.getElementById("btnStart");
const btnReset = document.getElementById("btnReset");
const btnHelp = document.getElementById("btnHelp");
const tips = document.getElementById("tips");
const videoEl = document.getElementById("cam");

const focusOverlay = document.getElementById("focusOverlay");
const focusTitleEl = document.getElementById("focusTitle");
const focusTextEl = document.getElementById("focusText");
const packetEl = document.getElementById("packet");
const horseVideo = document.getElementById("horseVideo");

// ---------------------------
// Three.js åŸºç¡€
// ---------------------------
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
  alpha: false,
  powerPreference: "high-performance"
});
renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio || 1));
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.08;

const scene = new THREE.Scene();
scene.background = new THREE.Color("#030304");

const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 140);
camera.position.set(0, 2.3, 10.4);

scene.add(new THREE.AmbientLight(0xffffff, 0.20));

const key = new THREE.DirectionalLight(0xfff2d6, 1.05);
key.position.set(6, 9, 6);
scene.add(key);

const goldPoint = new THREE.PointLight(0xd4af37, 1.25, 22, 2);
goldPoint.position.set(0, 5.2, 3.2);
scene.add(goldPoint);

const redPoint = new THREE.PointLight(0xb11226, 0.85, 18, 2);
redPoint.position.set(-2.8, 3.4, 2.6);
scene.add(redPoint);

// ---------------------------
// åæœŸè¾‰å…‰ï¼ˆBloomï¼‰
// ---------------------------
const BLOOM_LAYER = 1;

const bloomComposer = new EffectComposer(renderer);
bloomComposer.addPass(new RenderPass(scene, camera));

const bloomPass = new UnrealBloomPass(
  new THREE.Vector2(window.innerWidth, window.innerHeight),
  1.08,
  0.60,
  0.17
);
bloomComposer.addPass(bloomPass);

const finalComposer = new EffectComposer(renderer);
finalComposer.addPass(new RenderPass(scene, camera));

const bloomMixPass = new ShaderPass(
  new THREE.ShaderMaterial({
    uniforms: {
      baseTexture: { value: null },
      bloomTexture: { value: bloomComposer.renderTarget2.texture },
      uBloomIntensity: { value: 1.0 }
    },
    vertexShader: /* glsl */`
      varying vec2 vUv;
      void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }
    `,
    fragmentShader: /* glsl */`
      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;
      uniform float uBloomIntensity;
      varying vec2 vUv;
      void main(){
        vec4 base = texture2D(baseTexture, vUv);
        vec4 bloom = texture2D(bloomTexture, vUv);
        gl_FragColor = base + bloom * uBloomIntensity;
      }
    `
  }),
  "baseTexture"
);
finalComposer.addPass(bloomMixPass);
finalComposer.addPass(new OutputPass());

// ---------------------------
// ç”Ÿæˆ â€œé©¬â€ å­—ç²’å­çº¹ç†
// ---------------------------
function makeMaGlyphTexture(){
  const c = document.createElement("canvas");
  c.width = 256; c.height = 256;
  const ctx = c.getContext("2d");

  ctx.clearRect(0,0,256,256);

  const g = ctx.createRadialGradient(128,128,0,128,128,118);
  g.addColorStop(0, "rgba(212,175,55,0.22)");
  g.addColorStop(0.65, "rgba(212,175,55,0.06)");
  g.addColorStop(1, "rgba(212,175,55,0)");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,256,256);

  ctx.save();
  ctx.translate(128, 145);
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.font = "900 160px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.lineJoin = "round";
  ctx.lineWidth = 10;
  ctx.strokeStyle = "rgba(177,18,38,0.55)";
  ctx.strokeText("é©¬", 0, 0);
  ctx.fillStyle = "rgba(255,245,220,0.92)";
  ctx.fillText("é©¬", 0, 0);
  ctx.restore();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}
const MA_TEX = makeMaGlyphTexture();

// ---------------------------
// æ–‡å­—/å›¾å½¢é‡‡æ · -> ç‚¹ä½
// ---------------------------
function sampleCanvasPoints(drawFn, {
  step = IS_MOBILE ? 2 : 1,
  threshold = 10,
  worldWidth = 7.9,
  worldHeight = 3.8
} = {}){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d", { willReadFrequently: true });

  const cssW = 900;
  const cssH = 360;

  c.width  = Math.ceil(cssW * dpr);
  c.height = Math.ceil(cssH * dpr);

  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  drawFn(ctx, cssW, cssH);

  const img = ctx.getImageData(0,0,c.width,c.height).data;
  const pts = [];
  const stepPx = Math.max(1, Math.round(step * dpr));

  for(let y=0;y<c.height;y+=stepPx){
    for(let x=0;x<c.width;x+=stepPx){
      const a = img[(y*c.width + x)*4 + 3];
      if(a > threshold) pts.push([x/dpr, y/dpr]);
    }
  }

  const sx = worldWidth / cssW;
  const sy = worldHeight / cssH;

  const out = new Float32Array(pts.length*3);
  for(let i=0;i<pts.length;i++){
    const [xCss,yCss]=pts[i];
    const px=(xCss - cssW/2)*sx;
    const py=(cssH/2 - yCss)*sy;
    out[i*3+0]=px;
    out[i*3+1]=py;
    out[i*3+2]=0;
  }
  return out;
}

function sampleTextPoints(text, {
  fontSize = 190,
  step = IS_MOBILE ? 2 : 1,
  threshold = 8,
  worldWidth = 7.9
} = {}){
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d", { willReadFrequently: true });

  const font = `900 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
  ctx.font = font;
  const metrics = ctx.measureText(text);
  const pad = Math.ceil(fontSize * 0.42);
  const cssW = Math.ceil(metrics.width + pad * 2);
  const cssH = Math.ceil(fontSize * 1.25 + pad * 2);

  c.width  = Math.ceil(cssW * dpr);
  c.height = Math.ceil(cssH * dpr);

  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);

  ctx.font = font;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.lineJoin = "round";
  ctx.lineWidth = Math.max(10, Math.round(fontSize*0.06));
  ctx.strokeStyle = "rgba(177,18,38,1)";
  ctx.strokeText(text, cssW/2, cssH/2);
  ctx.fillStyle = "rgba(255,255,255,1)";
  ctx.fillText(text, cssW/2, cssH/2);

  const img = ctx.getImageData(0,0,c.width,c.height).data;
  const pts = [];
  const stepPx = Math.max(1, Math.round(step * dpr));

  for(let y=0;y<c.height;y+=stepPx){
    for(let x=0;x<c.width;x+=stepPx){
      const a = img[(y*c.width + x)*4 + 3];
      if(a > threshold) pts.push([x/dpr, y/dpr]);
    }
  }

  const scale = worldWidth / cssW;
  const out = new Float32Array(pts.length*3);
  for(let i=0;i<pts.length;i++){
    const [xCss,yCss]=pts[i];
    const px=(xCss - cssW/2)*scale;
    const py=(cssH/2 - yCss)*scale;
    out[i*3+0]=px;
    out[i*3+1]=py;
    out[i*3+2]=0;
  }
  return out;
}

// âœ… æ•£å¼€æ€ï¼šç”¨â€œğŸâ€é‡‡æ ·ä½œä¸ºå¥”è·‘é©¬è½®å»“ï¼ˆè‹¥ç³»ç»Ÿæ— å½©è‰²emojiä¹Ÿä¼šé€€åŒ–ä¸ºå­—ä½“æ›¿ä»£ï¼‰
function sampleRunningHorsePoints(){
  return sampleCanvasPoints((ctx, W, H)=>{
    ctx.save();
    ctx.translate(W/2, H/2);

    // èƒŒåæ·¡æ·¡å…‰æ™•
    const g = ctx.createRadialGradient(0,0,10,0,0,260);
    g.addColorStop(0, "rgba(255,255,255,0.10)");
    g.addColorStop(1, "rgba(255,255,255,0)");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(0,0,260,0,Math.PI*2);
    ctx.fill();

    // è½®å»“ï¼šä¼˜å…ˆ emoji
    const fontSize = 260;
    ctx.textAlign="center";
    ctx.textBaseline="middle";
    ctx.font = `900 ${fontSize}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji", ui-sans-serif, system-ui`;
    ctx.fillStyle = "rgba(255,255,255,1)";
    ctx.fillText("ğŸ", 0, 0);

    // è‹¥ emoji ä¸æ˜æ˜¾ï¼ŒåŠ ä¸€å±‚â€œé©¬â€åšå…œåº•
    ctx.font = `900 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
    ctx.globalAlpha = 0.22;
    ctx.fillText("é©¬", 0, 6);

    ctx.restore();
  }, {
    step: IS_MOBILE ? 2 : 1,
    threshold: 12,
    worldWidth: IS_MOBILE ? 5.6 : 6.2,
    worldHeight: IS_MOBILE ? 2.9 : 3.2
  });
}

function randn(){
  return (Math.random()+Math.random()+Math.random()+Math.random()-2.0);
}

// ---------------------------
// æ¨¡å¼ & è¿‡æ¸¡
// ---------------------------
const Mode = { MERGE:"MERGE", SCATTER:"SCATTER", FOCUS:"FOCUS" };
let mode = Mode.MERGE;

let mix = 0;
let targetMix = 0;

let focus = 0;
let targetFocus = 0;

function setMode(next){
  if(mode === next) return;
  mode = next;

  if(mode === Mode.MERGE){
    targetMix = 0;
    targetFocus = 0;
    hideFocusOverlay();
  }else if(mode === Mode.SCATTER){
    targetMix = 1;
    targetFocus = 0;
    hideFocusOverlay();
    kickScatterImpulse();
  }else{
    targetMix = 1;
    targetFocus = 1;
    showFocusOverlay();
  }
}

function showFocusOverlay(){ focusOverlay.classList.add("show"); }
function hideFocusOverlay(){ focusOverlay.classList.remove("show"); packetEl.classList.remove("open"); }

// ---------------------------
// æˆè¯­ç²’å­ç³»ç»Ÿï¼ˆMERGE: æˆè¯­ï¼›SCATTER: å¥”è·‘é©¬ + é“¶æ²³ç¯ç»•ï¼‰
// ---------------------------
const idiomGroup = new THREE.Group();
idiomGroup.position.set(0, 2.25, 0);
scene.add(idiomGroup);

let currentIdiom = "";
let idiomBounds = { minX:-3, maxX:3, minY:-1.5, maxY:1.5 };

const MAX_PARTICLES = IS_MOBILE ? 24000 : 38000;

// âœ… æ•£å¼€æ€åˆ†é…ï¼šå¤šå°‘æ¯”ä¾‹å˜æˆâ€œé©¬â€
const HORSE_RATIO = 0.32; // 0.28~0.38 éƒ½å¯

const idiomGeo = new THREE.BufferGeometry();

const aPos   = new Float32Array(MAX_PARTICLES*3);
const aVel   = new Float32Array(MAX_PARTICLES*3);
const aTar   = new Float32Array(MAX_PARTICLES*3);       // MERGEï¼ˆæˆè¯­ï¼‰ç›®æ ‡
const aTarH  = new Float32Array(MAX_PARTICLES*3);       // SCATTERï¼ˆé©¬å½¢ï¼‰ç›®æ ‡ï¼Œä»…å¯¹é©¬ç»„æœ‰æ•ˆ
const aSeed  = new Float32Array(MAX_PARTICLES);
const aKind  = new Float32Array(MAX_PARTICLES);         // 0=horse, 1=galaxy
const aOrbR  = new Float32Array(MAX_PARTICLES);         // galaxy orbit radius
const aOrbA  = new Float32Array(MAX_PARTICLES);         // galaxy base angle
const aOrbY  = new Float32Array(MAX_PARTICLES);         // galaxy height
const aOrbS  = new Float32Array(MAX_PARTICLES);         // galaxy angular speed

idiomGeo.setAttribute("position", new THREE.BufferAttribute(aPos, 3));
idiomGeo.setAttribute("aVel", new THREE.BufferAttribute(aVel, 3));
idiomGeo.setAttribute("aTar", new THREE.BufferAttribute(aTar, 3));
idiomGeo.setAttribute("aTarH", new THREE.BufferAttribute(aTarH, 3));
idiomGeo.setAttribute("aSeed", new THREE.BufferAttribute(aSeed, 1));
idiomGeo.setAttribute("aKind", new THREE.BufferAttribute(aKind, 1));
idiomGeo.setAttribute("aOrbR", new THREE.BufferAttribute(aOrbR, 1));
idiomGeo.setAttribute("aOrbA", new THREE.BufferAttribute(aOrbA, 1));
idiomGeo.setAttribute("aOrbY", new THREE.BufferAttribute(aOrbY, 1));
idiomGeo.setAttribute("aOrbS", new THREE.BufferAttribute(aOrbS, 1));

for(let i=0;i<MAX_PARTICLES;i++){
  const s = Math.random();
  aSeed[i] = s;

  // åˆå§‹éšæœºäº‘
  aPos[i*3+0]=(Math.random()-0.5)*3.2;
  aPos[i*3+1]=(Math.random()-0.5)*1.8;
  aPos[i*3+2]=(Math.random()-0.5)*1.4;

  aVel[i*3+0]=0; aVel[i*3+1]=0; aVel[i*3+2]=0;

  // åˆ†ç»„ï¼šå›ºå®šï¼ˆç¨³å®šï¼Œä¸ä¼šæ¥å›å˜ï¼‰
  const isHorse = (s < HORSE_RATIO);
  aKind[i] = isHorse ? 0.0 : 1.0;

  // galaxy å‚æ•°ï¼ˆç¨³å®šï¼‰
  const rr = lerp(1.2, IS_MOBILE ? 4.4 : 5.2, Math.pow(Math.random(), 0.55));
  aOrbR[i] = rr;
  aOrbA[i] = Math.random()*Math.PI*2;
  aOrbY[i] = lerp(-0.85, 0.85, Math.random()) * (IS_MOBILE ? 0.85 : 1.0);
  aOrbS[i] = lerp(0.55, 1.25, Math.random()) * (Math.random()<0.5 ? -1 : 1);

  // ç›®æ ‡æ•°ç»„é»˜è®¤ 0
  aTar[i*3+0]=0; aTar[i*3+1]=0; aTar[i*3+2]=0;
  aTarH[i*3+0]=0; aTarH[i*3+1]=0; aTarH[i*3+2]=0;
}

function rebuildIdiomTargets(text, { snap=false } = {}){
  currentIdiom = text;

  const pts = sampleTextPoints(text, {
    fontSize: 190,
    step: IS_MOBILE ? 2 : 1,
    worldWidth: IS_MOBILE ? 7.0 : 7.9
  });

  const targetN = Math.max(1, Math.min(MAX_PARTICLES, Math.floor(pts.length/3)));

  // è®¡ç®— boundsï¼ˆç”¨äºçº¢åŒ…ç¯ç»•åŠå¾„ï¼‰
  let minX= 1e9, maxX=-1e9, minY= 1e9, maxY=-1e9;
  for(let i=0;i<targetN;i++){
    const x = pts[i*3+0], y = pts[i*3+1];
    if(x<minX) minX=x; if(x>maxX) maxX=x;
    if(y<minY) minY=y; if(y>maxY) maxY=y;
  }
  idiomBounds = { minX, maxX, minY, maxY };

  const thickness = IS_MOBILE ? 0.65 : 0.95;
  const strokeJit = IS_MOBILE ? 0.035 : 0.05;

  for(let i=0;i<MAX_PARTICLES;i++){
    const idx = (i % targetN) * 3;
    const bx = pts[idx+0];
    const by = pts[idx+1];

    aTar[i*3+0] = bx + randn() * strokeJit * 0.55;
    aTar[i*3+1] = by + randn() * strokeJit * 0.55;

    const z = randn() * (thickness * 0.22);
    const z2 = randn() * (thickness * 0.14);
    aTar[i*3+2] = (z + z2);

    if(snap){
      aPos[i*3+0] = aTar[i*3+0] + (Math.random()-0.5)*0.03;
      aPos[i*3+1] = aTar[i*3+1] + (Math.random()-0.5)*0.03;
      aPos[i*3+2] = aTar[i*3+2] + (Math.random()-0.5)*0.03;
      aVel[i*3+0]=0; aVel[i*3+1]=0; aVel[i*3+2]=0;
    }
  }

  idiomGeo.attributes.aTar.needsUpdate = true;
  if(snap){
    idiomGeo.attributes.position.needsUpdate = true;
    idiomGeo.attributes.aVel.needsUpdate = true;
  }
}

function rebuildHorseTargets(){
  const horsePts = sampleRunningHorsePoints();
  const horseN = Math.max(1, Math.floor(horsePts.length/3));

  // é©¬å½¢ä½ç½®å¾®åç§»ï¼šæ›´åƒâ€œå‘å‰è·‘â€
  const ox = 0.0;
  const oy = 0.0;
  const oz = 0.0;

  // åšåº¦/ç«‹ä½“
  const thick = IS_MOBILE ? 0.45 : 0.70;
  const jit = IS_MOBILE ? 0.022 : 0.032;

  let j = 0;
  for(let i=0;i<MAX_PARTICLES;i++){
    if(aKind[i] !== 0.0) continue; // åªç»™é©¬ç»„å†™ç›®æ ‡
    const idx = (j % horseN) * 3;
    const x = horsePts[idx+0] + ox;
    const y = horsePts[idx+1] + oy;

    aTarH[i*3+0] = x + randn()*jit;
    aTarH[i*3+1] = y + randn()*jit*0.8;
    aTarH[i*3+2] = randn()*(thick*0.22) + randn()*(thick*0.14) + oz;

    j++;
  }
  idiomGeo.attributes.aTarH.needsUpdate = true;
}

// ---------------------------
// ç²’å­æè´¨
// ---------------------------
const idiomMat = new THREE.ShaderMaterial({
  transparent: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
  uniforms: {
    uTime: { value: 0 },
    uFocus: { value: 0 },
    uMap: { value: MA_TEX }
  },
  vertexShader: /* glsl */`
    uniform float uTime;
    uniform float uFocus;
    attribute float aSeed;
    varying float vSeed;
    varying float vGlow;
    void main(){
      vSeed = aSeed;
      vec3 p = position;

      float t = uTime*(0.40 + aSeed*0.85);
      // è½»å¾®å‘¼å¸ï¼ˆä¸ä¼šç ´åå›¾å½¢ï¼‰
      p.x += cos(t + aSeed*12.0) * (0.004 + aSeed*0.010);
      p.y += sin(t*0.9 + aSeed*10.0) * (0.004 + aSeed*0.010);
      p.z += sin(t*1.1 + aSeed* 8.0) * (0.003 + aSeed*0.008);

      p *= (1.0 + uFocus*(0.035 + aSeed*0.10));

      vec4 mv = modelViewMatrix * vec4(p, 1.0);
      gl_Position = projectionMatrix * mv;

      float dist = max(0.001, -mv.z);
      float base = 0.96;
      float tw = 0.88 + 0.12*sin(uTime*1.7 + aSeed*9.0);

      gl_PointSize = clamp(base*tw*(128.0/dist), 0.75, 2.35);
      vGlow = 0.55 + 0.45*sin(uTime*1.7 + aSeed*11.0);
    }
  `,
  fragmentShader: /* glsl */`
    precision highp float;
    uniform sampler2D uMap;
    varying float vSeed;
    varying float vGlow;
    void main(){
      vec4 m = texture2D(uMap, gl_PointCoord);
      if(m.a < 0.06) discard;

      vec3 gold = vec3(0.83,0.69,0.22);
      vec3 red  = vec3(0.70,0.07,0.15);
      vec3 warm = vec3(1.00,0.92,0.72);

      float k = smoothstep(0.20, 0.95, vSeed);
      vec3 col = mix(warm, gold, k);
      col = mix(col, red, smoothstep(0.78, 0.98, vSeed)*0.45);

      float a = m.a * (0.60 + 0.58*vGlow);
      gl_FragColor = vec4(col * (1.12 + 0.52*m.a), a);
    }
  `
});

const idiomPoints = new THREE.Points(idiomGeo, idiomMat);
idiomGroup.add(idiomPoints);
idiomPoints.layers.enable(BLOOM_LAYER);

// åˆå§‹å›ºå®šä¸€ä¸ªæˆè¯­ï¼ˆé¦–æ¬¡ snapï¼‰
rebuildIdiomTargets(IDIOMS[Math.floor(Math.random()*IDIOMS.length)], { snap:true });
// åˆå§‹å»ºç«‹é©¬å½¢ç›®æ ‡ï¼ˆæ•£å¼€æ—¶ç”¨ï¼‰
rebuildHorseTargets();

// ---------------------------
// çº¢åŒ…ç³»ç»Ÿï¼ˆä¿æŒä¸Šä¸€ç‰ˆï¼šç¼©å° + å¤§å°ä¸ä¸€ + å‡èšæ€å¸ƒæœ—è¿åŠ¨ï¼‰
// ---------------------------
const ENVELOPES = IS_MOBILE ? 190 : 300;

const envGroup = new THREE.Group();
envGroup.position.set(0, 2.25, 0);
scene.add(envGroup);

let envHomeRadius = 4.4;

function makeRedEnvelopeTexture(){
  const c = document.createElement("canvas");
  c.width=256; c.height=320;
  const ctx = c.getContext("2d");

  const g = ctx.createLinearGradient(0,0,0,320);
  g.addColorStop(0, "#d01a35");
  g.addColorStop(1, "#7b081a");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,256,320);

  ctx.strokeStyle = "rgba(212,175,55,.85)";
  ctx.lineWidth = 10;
  ctx.strokeRect(14,14,228,292);

  for(let i=0;i<18;i++){
    const x = Math.random()*256;
    const y = Math.random()*320;
    const r = 18+Math.random()*46;
    ctx.beginPath();
    ctx.fillStyle = `rgba(212,175,55,${0.04+Math.random()*0.06})`;
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();
  }

  ctx.save();
  ctx.translate(128,190);
  ctx.beginPath();
  ctx.fillStyle = "rgba(212,175,55,.92)";
  ctx.arc(0,0,42,0,Math.PI*2);
  ctx.fill();
  ctx.fillStyle = "rgba(90,60,10,.80)";
  ctx.font = "900 54px ui-sans-serif, system-ui, -apple-system";
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.fillText("ç¦", 0, 2);
  ctx.restore();

  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}
const ENV_TEX = makeRedEnvelopeTexture();

const envGeo = new THREE.PlaneGeometry(0.14, 0.18, 1, 1);
const envMat = new THREE.MeshBasicMaterial({
  map: ENV_TEX,
  transparent: true,
  opacity: 0.98,
  depthWrite: false,
  toneMapped: false
});
const envMesh = new THREE.InstancedMesh(envGeo, envMat, ENVELOPES);
envMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
envGroup.add(envMesh);
envMesh.layers.enable(BLOOM_LAYER);

const envHome = new Array(ENVELOPES);
const envScatter = new Array(ENVELOPES);
const envVel = new Array(ENVELOPES);
const envScale = new Array(ENVELOPES);
const envSeed = new Array(ENVELOPES);
const envBrown = new Array(ENVELOPES);
const envBrownVel = new Array(ENVELOPES);

function recomputeEnvHomeRadius(){
  const w = Math.max(3.4, (idiomBounds.maxX - idiomBounds.minX));
  const h = Math.max(1.8, (idiomBounds.maxY - idiomBounds.minY));
  envHomeRadius = Math.max(3.8, Math.min(6.0, Math.sqrt(w*w + h*h) * 0.95 + 1.25));
}

function sampleEnvelopeHomeWorld(){
  const R = envHomeRadius;
  const ang = Math.random() * Math.PI * 2;
  const r = R * (0.86 + Math.random()*0.42);
  const y = (Math.random()-0.5) * 2.6;
  const z = (Math.random()-0.5) * 3.2;
  return new THREE.Vector3(Math.cos(ang)*r, y, z);
}
function sampleScatterWorld(){
  const R = 10.8;
  const u = Math.random();
  const v = Math.random();
  const theta = u * Math.PI * 2;
  const phi = Math.acos(2 * v - 1);
  const rr = (0.35 + Math.pow(Math.random(), 0.55) * 0.65) * R;
  const x = rr * Math.sin(phi) * Math.cos(theta);
  const y = rr * Math.cos(phi) * 0.70 + 2.0;
  const z = rr * Math.sin(phi) * Math.sin(theta) - 1.8;
  return new THREE.Vector3(x,y,z);
}

recomputeEnvHomeRadius();

for(let i=0;i<ENVELOPES;i++){
  envHome[i] = sampleEnvelopeHomeWorld();
  envScatter[i] = sampleScatterWorld();
  envVel[i] = new THREE.Vector3(0,0,0);

  envScale[i] = lerp(0.55, 2.20, Math.pow(Math.random(), 0.72));
  envSeed[i] = Math.random()*1000;

  envBrown[i] = new THREE.Vector3(0,0,0);
  envBrownVel[i] = new THREE.Vector3(0,0,0);
}

const _obj = new THREE.Object3D();

function updateEnvelopes(time, dt){
  const brownAcc = 0.38;
  const brownDrag = 2.2;
  const brownSpring = 1.6;
  const brownMax = 0.55;

  for(let i=0;i<ENVELOPES;i++){
    const seed = envSeed[i];

    const mergeK = (1.0 - mix);
    if(mergeK > 0.02){
      const b = envBrown[i];
      const bv = envBrownVel[i];

      const nx = Math.sin(time*0.55 + seed*1.1) + Math.sin(time*0.31 + seed*2.3)*0.6;
      const ny = Math.cos(time*0.48 + seed*1.7) + Math.sin(time*0.29 + seed*3.1)*0.6;
      const nz = Math.sin(time*0.52 + seed*2.0) + Math.cos(time*0.33 + seed*2.9)*0.6;

      bv.x += nx * brownAcc * mergeK * dt;
      bv.y += ny * brownAcc * 0.75 * mergeK * dt;
      bv.z += nz * brownAcc * mergeK * dt;

      bv.x += (-b.x) * brownSpring * mergeK * dt;
      bv.y += (-b.y) * brownSpring * mergeK * dt;
      bv.z += (-b.z) * brownSpring * mergeK * dt;

      const d = Math.exp(-brownDrag * dt);
      bv.multiplyScalar(d);

      b.addScaledVector(bv, dt);
      if(b.length() > brownMax){
        b.normalize().multiplyScalar(brownMax);
        bv.multiplyScalar(0.35);
      }
    }

    const home = envHome[i];
    const b = envBrown[i];

    const hx = home.x + b.x;
    const hy = home.y + b.y;
    const hz = home.z + b.z;

    const s = envScatter[i];
    const v = envVel[i];

    v.multiplyScalar(Math.pow(0.94, dt*60.0));
    if(mix > 0.35){
      const n1 = Math.sin(time*0.7 + seed*0.9);
      const n2 = Math.cos(time*0.65 + seed*1.1);
      const n3 = Math.sin(time*0.55 + seed*1.3);
      v.x += n1 * 0.18 * dt;
      v.y += n2 * 0.10 * dt;
      v.z += n3 * 0.18 * dt;
    }
    s.addScaledVector(v, dt);

    const x = lerp(hx, s.x, mix);
    const y = lerp(hy, s.y, mix);
    const z = lerp(hz, s.z, mix);

    _obj.position.set(x,y,z);
    _obj.quaternion.copy(camera.quaternion);
    _obj.rotateZ(Math.sin(time*0.7 + seed)*0.22);
    _obj.scale.setScalar(envScale[i] * (1.0 - focus*0.10));
    _obj.updateMatrix();
    envMesh.setMatrixAt(i, _obj.matrix);
  }
  envMesh.instanceMatrix.needsUpdate = true;
}

function kickScatterImpulse(){
  for(let i=0;i<MAX_PARTICLES;i++){
    const sx = (Math.random()-0.5);
    const sy = (Math.random()-0.2);
    const sz = (Math.random()-0.5);
    const len = Math.max(1e-4, Math.sqrt(sx*sx+sy*sy+sz*sz));
    const k = 2.2 + Math.random()*3.8;
    aVel[i*3+0] += (sx/len)*k;
    aVel[i*3+1] += (sy/len)*k;
    aVel[i*3+2] += (sz/len)*k;
  }
  idiomGeo.attributes.aVel.needsUpdate = true;

  for(let i=0;i<ENVELOPES;i++){
    const p = envScatter[i];
    const dir = p.clone().normalize();
    dir.x += (Math.random()-0.5)*0.45;
    dir.y += (Math.random()-0.2)*0.35;
    dir.z += (Math.random()-0.5)*0.45;
    dir.normalize();
    const kick = 5.2 + Math.random()*6.8;
    envVel[i].addScaledVector(dir, kick);
  }
}

// ---------------------------
// èƒŒæ™¯çƒŸèŠ±ï¼ˆä¿ç•™ä¸Šä¸€ç‰ˆå®ç°ï¼‰
// ---------------------------
function smoothstep(a,b,x){
  const t = clamp((x-a)/(b-a), 0, 1);
  return t*t*(3-2*t);
}

class Fireworks {
  constructor(maxParticles=6500, maxRockets=8){
    this.max = maxParticles;
    this.pos = new Float32Array(this.max*3);
    this.vel = new Float32Array(this.max*3);
    this.col = new Float32Array(this.max*3);
    this.life= new Float32Array(this.max);
    this.age = new Float32Array(this.max);
    this.active = new Uint8Array(this.max);

    this.geo = new THREE.BufferGeometry();
    this.geo.setAttribute("position", new THREE.BufferAttribute(this.pos,3));
    this.geo.setAttribute("color", new THREE.BufferAttribute(this.col,3));

    this.mat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      blending: THREE.AdditiveBlending,
      uniforms:{ uTime:{value:0} },
      vertexShader:/*glsl*/`
        uniform float uTime;
        attribute vec3 color;
        varying vec3 vColor;
        void main(){
          vColor = color;
          vec4 mv = modelViewMatrix * vec4(position,1.0);
          gl_Position = projectionMatrix * mv;
          float dist = max(0.001, -mv.z);
          gl_PointSize = clamp(1.35*(210.0/dist), 0.55, 3.2);
        }
      `,
      fragmentShader:/*glsl*/`
        precision highp float;
        varying vec3 vColor;
        void main(){
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);
          float core = smoothstep(0.18, 0.0, d);
          float halo = smoothstep(0.55, 0.16, d) * 0.38;
          float a = core + halo;
          if(a < 0.01) discard;
          gl_FragColor = vec4(vColor*(1.10 + 0.55*halo), a);
        }
      `
    });

    this.points = new THREE.Points(this.geo, this.mat);
    this.points.frustumCulled = false;
    scene.add(this.points);
    this.points.layers.enable(BLOOM_LAYER);

    this.rockets = [];
    this.maxRockets = maxRockets;
    this.spawnTimer = 0;
  }

  hsvToRgb(h,s,v){
    const i = Math.floor(h*6);
    const f = h*6 - i;
    const p = v*(1-s);
    const q = v*(1-f*s);
    const t = v*(1-(1-f)*s);
    const m = i % 6;
    const r = [v,q,p,p,t,v][m];
    const g = [t,v,v,q,p,p][m];
    const b = [p,p,t,v,v,q][m];
    return [r,g,b];
  }

  allocParticle(){
    for(let i=0;i<this.max;i++){
      if(this.active[i]===0) return i;
    }
    return -1;
  }

  spawnRocket(){
    if(this.rockets.length >= this.maxRockets) return;

    const ox = (Math.random()-0.5)*18;
    const oz = -10 - Math.random()*22;
    const targetY = 6.0 + Math.random()*6.5;

    this.rockets.push({
      x: ox, y: 0.8 + Math.random()*0.8, z: oz,
      vx: (Math.random()-0.5)*0.6,
      vy: 7.5 + Math.random()*2.8,
      vz: (Math.random()-0.5)*0.6,
      targetY,
      col: [1.0, 0.92, 0.70]
    });
  }

  spawnBurst(origin, count=170){
    const baseH = Math.random();
    const baseS = 0.70 + Math.random()*0.28;
    const baseV = 0.82 + Math.random()*0.18;

    for(let n=0;n<count;n++){
      const idx = this.allocParticle();
      if(idx<0) break;

      this.active[idx]=1;
      this.age[idx]=0;
      this.life[idx]=1.35 + Math.random()*1.00;

      const h = (baseH + (Math.random()-0.5)*0.08 + 1.0) % 1.0;
      const s = clamp(baseS + (Math.random()-0.5)*0.10, 0.55, 1.0);
      const v = clamp(baseV + (Math.random()-0.5)*0.08, 0.65, 1.0);
      const [r,g,b]=this.hsvToRgb(h,s,v);

      this.col[idx*3+0]=r;
      this.col[idx*3+1]=g;
      this.col[idx*3+2]=b;

      this.pos[idx*3+0]=origin.x + (Math.random()-0.5)*0.10;
      this.pos[idx*3+1]=origin.y + (Math.random()-0.5)*0.10;
      this.pos[idx*3+2]=origin.z + (Math.random()-0.5)*0.10;

      const u=Math.random();
      const v2=Math.random();
      const theta=u*Math.PI*2;
      const phi=Math.acos(2*v2-1);

      const speed = 3.2 + Math.pow(Math.random(), 0.55)*5.0;
      const sx = Math.sin(phi)*Math.cos(theta);
      const sy = Math.cos(phi);
      const sz = Math.sin(phi)*Math.sin(theta);

      this.vel[idx*3+0]=sx*speed;
      this.vel[idx*3+1]=sy*speed*0.78 + 1.1;
      this.vel[idx*3+2]=sz*speed;
    }
  }

  update(dt, time){
    this.spawnTimer -= dt;
    if(this.spawnTimer <= 0){
      this.spawnTimer = 0.55 + Math.random()*0.65;
      this.spawnRocket();
    }

    for(let r=this.rockets.length-1;r>=0;r--){
      const rocket = this.rockets[r];

      rocket.vx *= Math.pow(0.985, dt*60);
      rocket.vy *= Math.pow(0.992, dt*60);
      rocket.vz *= Math.pow(0.985, dt*60);

      rocket.x += rocket.vx*dt;
      rocket.y += rocket.vy*dt;
      rocket.z += rocket.vz*dt;

      if(Math.random() < 0.35){
        const idx = this.allocParticle();
        if(idx>=0){
          this.active[idx]=1;
          this.age[idx]=0;
          this.life[idx]=0.55 + Math.random()*0.35;

          this.col[idx*3+0]=rocket.col[0]*0.95;
          this.col[idx*3+1]=rocket.col[1]*0.80;
          this.col[idx*3+2]=rocket.col[2]*0.55;

          this.pos[idx*3+0]=rocket.x + (Math.random()-0.5)*0.08;
          this.pos[idx*3+1]=rocket.y + (Math.random()-0.5)*0.08;
          this.pos[idx*3+2]=rocket.z + (Math.random()-0.5)*0.08;

          this.vel[idx*3+0]=(Math.random()-0.5)*1.0;
          this.vel[idx*3+1]=-(2.0 + Math.random()*2.0);
          this.vel[idx*3+2]=(Math.random()-0.5)*1.0;
        }
      }

      if(rocket.y >= rocket.targetY){
        this.spawnBurst(new THREE.Vector3(rocket.x, rocket.y, rocket.z), IS_MOBILE ? 130 : 190);
        this.rockets.splice(r,1);
      }
    }

    for(let i=0;i<this.max;i++){
      if(this.active[i]===0) continue;

      this.age[i] += dt;
      const t = this.age[i]/this.life[i];
      if(t >= 1){
        this.active[i]=0;
        this.pos[i*3+0]=9999;
        this.pos[i*3+1]=9999;
        this.pos[i*3+2]=9999;
        continue;
      }

      this.vel[i*3+1] -= 3.0 * dt;
      const dampK = Math.pow(0.986, dt*60);
      this.vel[i*3+0] *= dampK;
      this.vel[i*3+1] *= dampK;
      this.vel[i*3+2] *= dampK;

      this.pos[i*3+0] += this.vel[i*3+0]*dt;
      this.pos[i*3+1] += this.vel[i*3+1]*dt;
      this.pos[i*3+2] += this.vel[i*3+2]*dt;
    }

    this.geo.attributes.position.needsUpdate = true;
    this.geo.attributes.color.needsUpdate = true;
    this.mat.uniforms.uTime.value = time;
  }
}
const fireworks = new Fireworks(IS_MOBILE ? 5200 : 6800, IS_MOBILE ? 6 : 8);

// ---------------------------
// ç›¸æœºæ§åˆ¶
// ---------------------------
let yaw=0.0, pitch=0.14, radius=10.4;
let yawT=yaw, pitchT=pitch;

let dragging=false, lastX=0, lastY=0, lastTap=0;

canvas.addEventListener("pointerdown",(e)=>{
  dragging=true; lastX=e.clientX; lastY=e.clientY;
});
window.addEventListener("pointerup",()=>dragging=false);
window.addEventListener("pointermove",(e)=>{
  if(!dragging) return;
  if(mode !== Mode.SCATTER) return;
  const dx=e.clientX-lastX;
  const dy=e.clientY-lastY;
  lastX=e.clientX; lastY=e.clientY;
  yawT += dx*0.0042;
  pitchT += dy*0.0032;
});

canvas.addEventListener("click", ()=>{
  const now = performance.now();
  if(now - lastTap < 360){
    triggerRedPacketFlow();
  }
  lastTap = now;
});

// ---------------------------
// çº¢åŒ…å¼€å°æµç¨‹
// ---------------------------
function pickIdiom(){
  return IDIOMS[Math.floor(Math.random()*IDIOMS.length)];
}
function pickVideo(){
  return HORSE_VIDEOS[Math.floor(Math.random()*HORSE_VIDEOS.length)];
}

async function triggerRedPacketFlow(){
  if(mode !== Mode.FOCUS){
    setMode(Mode.FOCUS);
  }

  const idiom = pickIdiom();
  focusTitleEl.textContent = "çº¢åŒ…åˆ° Â· å¥½è¿åˆ°";
  focusTextEl.textContent = `æ­å–œä½ æŠ“åˆ°ä¸€ä¸ªçº¢åŒ…ï¼\n\n${idiom}`;

  packetEl.classList.remove("open");
  void packetEl.offsetWidth;
  packetEl.classList.add("open");

  const url = pickVideo();
  try{
    horseVideo.pause();
    horseVideo.src = url;
    horseVideo.load();
    await horseVideo.play().catch(()=>{});
  }catch(e){}
}

// ---------------------------
// æ‰‹åŠ¿è¯†åˆ«ï¼ˆMediaPipe Handsï¼‰
// ---------------------------
let hands = null;
let handEnabled = false;
let lastLandmarks = null;
let lastLandmarksTs = 0;

function dist3(a,b){
  const dx=a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0);
  return Math.sqrt(dx*dx+dy*dy+dz*dz);
}

function computeGesture(landmarks){
  const wrist=landmarks[0];
  const handSize=Math.max(1e-6, dist3(wrist, landmarks[9]));

  function extended(tip,pip){
    const dt=dist3(landmarks[tip], wrist);
    const dp=dist3(landmarks[pip], wrist);
    return dt > dp*1.12;
  }

  const thumbExt = extended(4,2);
  const indexExt = extended(8,6);
  const middleExt= extended(12,10);
  const ringExt  = extended(16,14);
  const pinkyExt = extended(20,18);

  const extCount = [thumbExt,indexExt,middleExt,ringExt,pinkyExt].filter(Boolean).length;
  const fist = (extCount <= 1);

  const th = landmarks[4], ix = landmarks[8], md = landmarks[12];
  const dTI = dist3(th, ix) / handSize;
  const dTM = dist3(th, md) / handSize;
  const dIM = dist3(ix, md) / handSize;
  const threePinch = (!fist) && (dTI < 0.40) && (dTM < 0.44) && (dIM < 0.40);

  const openHand = (extCount >= 4);

  const palmIdx=[0,5,9,13,17];
  const palm={x:0,y:0,z:0};
  for(const i of palmIdx){ palm.x+=landmarks[i].x; palm.y+=landmarks[i].y; palm.z+=landmarks[i].z; }
  palm.x/=palmIdx.length; palm.y/=palmIdx.length; palm.z/=palmIdx.length;

  return { palm, openHand, fist, threePinch };
}

let lastPalmX=null, lastPalmY=null;
let prevOpen=false, prevFist=false, prevThreePinch=false;
let pinchCooldown=0;

function handleGesture(g, dt){
  if(g.fist && !prevFist){
    const newIdiom = pickIdiom();
    rebuildIdiomTargets(newIdiom, { snap:false });
    recomputeEnvHomeRadius();
    setMode(Mode.MERGE);
    statusText.textContent = `æ”¶æ‹¢ä¸­ â†’ å‡èšï¼š${newIdiom}`;
  }else if(g.openHand && !prevOpen){
    // âœ… æ•£å¼€ï¼šé©¬å½¢+é“¶æ²³ï¼ˆç›®æ ‡å·²å‡†å¤‡å¥½ï¼‰
    setMode(Mode.SCATTER);
    statusText.textContent = "æ•£å¼€æ€ï¼šå¥”è·‘é©¬å½¢ç²’å­ + é“¶æ²³ç¯ç»•ï¼ˆç§»åŠ¨æ‰‹æŒå¯æ—‹è½¬è§†è§’ï¼‰";
  }else{
    pinchCooldown = Math.max(0, pinchCooldown - dt);
    if(g.threePinch && !prevThreePinch && pinchCooldown<=0 && !g.fist && !g.openHand){
      triggerRedPacketFlow();
      pinchCooldown = 0.55;
    }
  }

  if(mode===Mode.SCATTER && !g.fist && !g.threePinch){
    const x=g.palm.x, y=g.palm.y;
    if(lastPalmX!=null){
      const dx=x-lastPalmX;
      const dy=y-lastPalmY;
      yawT += (-dx)*4.2;
      pitchT += ( dy)*3.0;
    }
    lastPalmX=x; lastPalmY=y;
  }else{
    lastPalmX=lastPalmY=null;
  }

  prevOpen = g.openHand;
  prevFist = g.fist;
  prevThreePinch = g.threePinch;
}

async function startHands(){
  if(!window.Hands){
    statusText.textContent="æ‰‹åŠ¿ç»„ä»¶æœªåŠ è½½ï¼ˆç½‘ç»œé—®é¢˜ï¼Ÿï¼‰";
    return;
  }
  if(!navigator.mediaDevices?.getUserMedia){
    statusText.textContent="å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´ API";
    return;
  }

  hands = new window.Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.6,
    minTrackingConfidence: 0.6
  });
  hands.onResults((results)=>{
    const lm = results.multiHandLandmarks?.[0] || null;
    if(lm){
      lastLandmarks = lm;
      lastLandmarksTs = performance.now();
    }
  });

  const stream = await navigator.mediaDevices.getUserMedia({
    audio:false,
    video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} }
  });

  videoEl.srcObject=stream;
  await videoEl.play();

  handEnabled=true;
  led.classList.add("on");
  statusText.textContent="æ‰‹åŠ¿å·²å¯ç”¨ï¼šæ¡æ‹³=å‡èšæˆè¯­ / å¼ å¼€=é©¬å½¢+é“¶æ²³ / ä¸‰æŒ‡æåˆ=æŠ“çº¢åŒ…";

  let busy=false, lastSent=0;
  async function pump(){
    if(!handEnabled) return;
    const now=performance.now();
    if(!busy && (now-lastSent)>33){
      busy=true; lastSent=now;
      try{ await hands.send({ image: videoEl }); }catch(e){}
      busy=false;
    }
    requestAnimationFrame(pump);
  }
  pump();
}

btnStart.addEventListener("click", async ()=>{
  try{
    btnStart.disabled=true;
    btnStart.textContent="å¯ç”¨ä¸­â€¦";
    await startHands();
    btnStart.textContent="æ‰‹åŠ¿è¯†åˆ«å·²å¼€å¯";
  }catch(e){
    statusText.textContent="å¯ç”¨å¤±è´¥ï¼šè¯·å…è®¸æ‘„åƒå¤´æƒé™ï¼Œå¹¶ç¡®ä¿ HTTPSï¼ˆGitHub Pages é»˜è®¤æ»¡è¶³ï¼‰";
    btnStart.disabled=false;
    btnStart.textContent="å¯ç”¨æ‰‹åŠ¿è¯†åˆ«";
  }
});

btnHelp.addEventListener("click", ()=>{
  tips.style.display = (tips.style.display==="none") ? "flex" : "none";
});

btnReset.addEventListener("click", ()=>{
  const newIdiom = pickIdiom();
  rebuildIdiomTargets(newIdiom, { snap:true });
  rebuildHorseTargets();
  recomputeEnvHomeRadius();

  for(let i=0;i<ENVELOPES;i++){
    envHome[i]=sampleEnvelopeHomeWorld();
    envScatter[i]=sampleScatterWorld();
    envVel[i].set(0,0,0);
    envBrown[i].set(0,0,0);
    envBrownVel[i].set(0,0,0);
  }

  hideFocusOverlay();
  setMode(Mode.MERGE);
  mix = 0; targetMix = 0;

  prevOpen = prevFist = prevThreePinch = false;
  pinchCooldown = 0;

  statusText.textContent=`å·²é‡ç½®ï¼šåˆæ‹¢ç¨³å®šæ€ï¼š${newIdiom}`;
});

// ---------------------------
// æ¸²æŸ“å¾ªç¯
// ---------------------------
let time=0;
let lastTime=performance.now();

function applyCamera(dt){
  if(mode===Mode.MERGE){
    yawT = damp(yawT, 0.0, 2.4, dt);
    pitchT = damp(pitchT, 0.14, 2.8, dt);
  }else if(mode===Mode.FOCUS){
    yawT = damp(yawT, 0.0, 3.0, dt);
    pitchT = damp(pitchT, 0.12, 3.0, dt);
  }else{
    pitchT = clamp(pitchT, -0.22, 0.62);
  }

  yaw = damp(yaw, yawT, 6.0, dt);
  pitch = damp(pitch, pitchT, 6.0, dt);

  const r=radius;
  const cx = Math.sin(yaw)*Math.cos(pitch)*r;
  const cy = 2.25 + Math.sin(pitch)*r*0.33;
  const cz = Math.cos(yaw)*Math.cos(pitch)*r;
  camera.position.set(cx,cy,cz);
  camera.lookAt(0,2.25,0);

  goldPoint.position.set(
    Math.sin(yaw*0.7)*2.0,
    5.0 + Math.sin(time*0.7)*0.12,
    3.0 + Math.cos(yaw*0.7)*1.2
  );
}

function updateIdiom(dt){
  // âœ… å‡èšæ€ç»•Yè½´æ—‹è½¬ï¼›æ•£å¼€æ€å¼±ä¸€äº›ï¼ˆè®©é“¶æ²³æ›´æ˜¾çœ¼ï¼‰
  const rotSpeed =
    (mode===Mode.MERGE)  ? 0.22 :
    (mode===Mode.SCATTER)? 0.10 : 0.0;
  idiomGroup.rotation.y += dt * rotSpeed;

  // åŠ¨åŠ›å‚æ•°ï¼šè®©å½¢ä½“æ›´ç¨³ï¼ˆé©¬æ›´ç¨³ã€é“¶æ²³æ›´ä¸æ»‘ï¼‰
  const springMerge = 18.0;
  const springScatter = 14.0;
  const drag = 7.8;

  // é“¶æ²³ä¸­å¿ƒï¼ˆç›¸å¯¹ idiomGroup çš„å±€éƒ¨åæ ‡ï¼‰
  const cx = 0.0, cy = 0.0, cz = 0.0;

  // é“¶æ²³å€¾è§’ï¼ˆè®©å®ƒåƒâ€œé“¶æ²³ç›˜â€ï¼‰
  const tilt = 0.42; // radians
  const ct = Math.cos(tilt), st = Math.sin(tilt);

  for(let i=0;i<MAX_PARTICLES;i++){
    const px=aPos[i*3+0], py=aPos[i*3+1], pz=aPos[i*3+2];
    let vx=aVel[i*3+0], vy=aVel[i*3+1], vz=aVel[i*3+2];

    const mergeK = (1.0 - mix);
    const scatterK = mix;

    // MERGE ç›®æ ‡ï¼ˆæˆè¯­ï¼‰
    const mx=aTar[i*3+0], my=aTar[i*3+1], mz=aTar[i*3+2];

    // SCATTER ç›®æ ‡ï¼šé©¬ or é“¶æ²³
    let sx=0, sy=0, sz=0;

    if(aKind[i] === 0.0){
      // é©¬å½¢ï¼šä½¿ç”¨ aTarH
      sx = aTarH[i*3+0];
      sy = aTarH[i*3+1];
      sz = aTarH[i*3+2];

      // å°å¹…â€œå¥”è·‘æ„Ÿâ€æ‘†åŠ¨ï¼ˆä¸ç ´åè½®å»“ï¼‰
      const s = aSeed[i];
      sx += Math.sin(time*2.2 + s*9.0) * 0.010;
      sy += Math.sin(time*3.0 + s*7.0) * 0.006;
    }else{
      // é“¶æ²³ï¼šå›´ç»•é©¬æ—‹è½¬
      const s = aSeed[i];
      const r = aOrbR[i];
      const ang = aOrbA[i] + time * aOrbS[i] * (0.9 + s*0.25);

      let x = Math.cos(ang) * r;
      let z = Math.sin(ang) * r;

      // è®©é“¶æ²³æ›´â€œæ¡å¸¦â€ï¼šæŠŠåŠå¾„åšä¸€ç‚¹å‘¼å¸
      const rr = r * (0.96 + 0.04*Math.sin(time*0.8 + s*10.0));
      x = Math.cos(ang) * rr;
      z = Math.sin(ang) * rr;

      // y è½»å¾®ä¸Šä¸‹æ³¢
      let y = aOrbY[i] + Math.sin(time*0.9 + s*8.0) * 0.10;

      // å€¾æ–œé“¶æ²³ç›˜ï¼ˆç»•Xè½´ï¼‰
      const y2 = y*ct - z*st;
      const z2 = y*st + z*ct;

      sx = cx + x;
      sy = cy + y2;
      sz = cz + z2;

      // é“¶æ²³â€œé¢—ç²’â€è½»å¾®æŠ–åŠ¨ï¼ˆä¸ä¼šæŠ–æ•£ï¼‰
      sx += Math.sin(time*1.7 + s*21.0) * 0.010;
      sy += Math.cos(time*1.3 + s*17.0) * 0.008;
      sz += Math.sin(time*1.5 + s*19.0) * 0.010;
    }

    // æœ€ç»ˆç›®æ ‡ï¼šåœ¨ MERGE ä¸ SCATTER ä¹‹é—´æ’å€¼ï¼ˆä¿è¯æ”¶æ‹¢æ—¶åªå‘ˆç°æˆè¯­ï¼‰
    const tx = lerp(mx, sx, scatterK);
    const ty = lerp(my, sy, scatterK);
    const tz = lerp(mz, sz, scatterK);

    // å¸é™„ï¼šåœ¨å„è‡ªçŠ¶æ€ä¸‹éƒ½ä¿æŒç¨³å®š
    const spring = springMerge*mergeK + springScatter*scatterK;
    vx += (tx - px) * spring * dt;
    vy += (ty - py) * spring * dt;
    vz += (tz - pz) * spring * dt;

    // æ•£å¼€æ—¶ç»™ä¸€ç‚¹æµä½“æ„Ÿï¼ˆä¸ä¼šç ´åé©¬/é“¶æ²³ï¼‰
    if(scatterK > 0.2){
      const s = aSeed[i];
      const wob = scatterK * 0.06;
      vx += Math.sin(time*0.7 + s*9.0) * wob * dt;
      vy += Math.cos(time*0.65 + s*8.0) * (wob*0.7) * dt;
      vz += Math.sin(time*0.55 + s*7.0) * wob * dt;
    }

    vx *= Math.exp(-drag*dt);
    vy *= Math.exp(-drag*dt);
    vz *= Math.exp(-drag*dt);

    aPos[i*3+0] = px + vx;
    aPos[i*3+1] = py + vy;
    aPos[i*3+2] = pz + vz;

    aVel[i*3+0]=vx; aVel[i*3+1]=vy; aVel[i*3+2]=vz;
  }

  idiomGeo.attributes.position.needsUpdate = true;
  idiomGeo.attributes.aVel.needsUpdate = true;

  idiomMat.uniforms.uTime.value = time;
  idiomMat.uniforms.uFocus.value = focus;
}

function updateMood(dt){
  if(mode===Mode.MERGE){
    bloomPass.strength = damp(bloomPass.strength, 1.08, 2.8, dt);
    bloomPass.radius   = damp(bloomPass.radius,   0.60, 2.8, dt);
    bloomPass.threshold= damp(bloomPass.threshold,0.17, 2.8, dt);
    renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.08, 2.2, dt);
  }else if(mode===Mode.SCATTER){
    bloomPass.strength = damp(bloomPass.strength, 1.16, 2.8, dt);
    bloomPass.radius   = damp(bloomPass.radius,   0.66, 2.8, dt);
    bloomPass.threshold= damp(bloomPass.threshold,0.16, 2.8, dt);
    renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.10, 2.2, dt);
  }else{
    bloomPass.strength = damp(bloomPass.strength, 1.22, 2.8, dt);
    bloomPass.radius   = damp(bloomPass.radius,   0.70, 2.8, dt);
    bloomPass.threshold= damp(bloomPass.threshold,0.15, 2.8, dt);
    renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.12, 2.2, dt);
  }
}

function animate(){
  const now=performance.now();
  const dt=clamp((now-lastTime)/1000, 0, 0.035);
  lastTime=now;
  time += dt;

  if(handEnabled && lastLandmarks && (now-lastLandmarksTs) < 180){
    const g = computeGesture(lastLandmarks);
    handleGesture(g, dt);
  }

  // âœ… æ”¶æ‹¢æ›´ä¸æ»‘ï¼šmix ä¸‹é™æ…¢ä¸€ç‚¹
  const mixLambda = (targetMix < mix) ? 1.65 : 2.4;
  mix = damp(mix, targetMix, mixLambda, dt);

  targetFocus = (mode===Mode.FOCUS) ? 1 : 0;
  focus = damp(focus, targetFocus, 4.0, dt);

  bloomMixPass.material.uniforms.uBloomIntensity.value = lerp(1.0, 0.34, focus);

  applyCamera(dt);
  updateIdiom(dt);
  updateEnvelopes(time, dt);
  fireworks.update(dt, time);
  updateMood(dt);

  camera.layers.set(BLOOM_LAYER);
  bloomComposer.render();

  camera.layers.set(0);
  finalComposer.render();

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// ---------------------------
// Resize
// ---------------------------
function onResize(){
  const w=window.innerWidth, h=window.innerHeight;
  camera.aspect=w/h; camera.updateProjectionMatrix();
  renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio || 1));
  renderer.setSize(w,h,false);
  bloomComposer.setSize(w,h);
  finalComposer.setSize(w,h);
  bloomPass.setSize?.(w,h);
}
window.addEventListener("resize", onResize);

// ---------------------------
// åˆå§‹æç¤º & åˆå§‹çº¢åŒ…
// ---------------------------
statusText.textContent = `å·²åŠ è½½ï¼šåˆæ‹¢ç¨³å®šæ€ï¼š${currentIdiom}ï¼ˆå¯ç‚¹å‡»â€œå¯ç”¨æ‰‹åŠ¿è¯†åˆ«â€ï¼‰`;

horseVideo.muted = true;
horseVideo.loop = true;
horseVideo.playsInline = true;

// åˆå§‹åŒ–çº¢åŒ… homeï¼ˆä¾èµ– envHomeRadiusï¼‰
for(let i=0;i<ENVELOPES;i++){
  envHome[i] = sampleEnvelopeHomeWorld();
}
</script>
</body>
</html>
